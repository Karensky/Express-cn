<html>

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>Express-CN</title>
	<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet"
		type="text/css" />
	<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet"
		type="text/css" />
	<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css" />
	<style>
		pre {
			counter-reset: line-numbering;
			border: solid 1px #d9d9d9;
			border-radius: 0;
			background: #fff;
			padding: 0;
			line-height: 23px;
			margin-bottom: 30px;
			white-space: pre;
			overflow-x: auto;
			word-break: inherit;
			word-wrap: inherit;
		}

		pre a::before {
			content: counter(line-numbering);
			counter-increment: line-numbering;
			padding-right: 1em;
			/* space after numbers */
			width: 25px;
			text-align: right;
			opacity: 0.7;
			display: inline-block;
			color: #aaa;
			background: #eee;
			margin-right: 16px;
			padding: 2px 10px;
			font-size: 13px;
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}

		pre a:first-of-type::before {
			padding-top: 10px;
		}

		pre a:last-of-type::before {
			padding-bottom: 10px;
		}

		pre a:only-of-type::before {
			padding: 10px;
		}

		.highlight {
			background-color: #ffffcc
		}

		/* RIGHT */
	</style>
</head>

<body>
	<div>
		<div style='width:25%;'>
			<ul id="tree" class="ztree" style='width:100%'>

			</ul>
		</div>
		<div id='readme' style='width:70%;margin-left:20%;'>
			<article class='markdown-body'>
				<h1 id="-">快速入门</h1>
				<h2 id="-">安装</h2>
				<p>首先假定你已经安装了 <a href="https://nodejs.org/">Node.js</a>，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。</p>
				<pre><code class="lang-console">$ mkdir myapp
$ cd myapp
</code></pre>
				<p>通过 <code>npm init</code> 命令为你的应用创建一个 <code>package.json</code> 文件。 欲了解 <code>package.json</code>
					是如何起作用的，请参考 <a href="https://docs.npmjs.com/files/package.json">Specifics of npm’s package.json
						handling</a>.</p>
				<pre><code class="lang-console">$ npm init
</code></pre>
				<p>此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受大部分默认设置即可，下面这个除外：</p>
				<pre><code>entry point: (index.js)
</code></pre>
				<p>键入 <code>app.js</code> 或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的 <code>index.js</code> 文件名，只需按“回车”键即可。</p>
				<p>接下来在 <code>myapp</code> 目录下安装 Express 并将其保存到依赖列表中。如下：</p>
				<pre><code class="lang-console">$ npm install express --save
</code></pre>
				<p>如果只是临时安装 Express，不想将它添加到依赖列表中，可执行如下命令：</p>
				<pre><code class="lang-console">$ npm install express --no-save
</code></pre>
				<p>npm 5.0+ 版本在默认情况下会将安装的模块添加到 <code>package.json</code> 文件中的 <code>dependencies</code> 列表中。对于较老的 npm
					版本，你就必须指定 <code>--save</code> 参数。然后，照旧执行 <code>npm install</code> 命令即可自动安装依赖列表中所列出的所有模块。</p>

			</article>
			
			<article class='markdown-body'>
            	<h2 id="hello-world">Hello World</h2>
<p>以下是关于创建最简单的 Express 应用程序的说明，以及如何在本地运行它的步骤：</p>
<ol>
<li><p><strong>创建目录并初始化 npm：</strong> 创建一个名为 <code>myapp</code> 的目录，进入该目录，并使用以下命令初始化一个 <code>package.json</code> 文件：</p>
<pre><code>bashCopy codemkdir myapp
cd myapp
npm init
</code></pre></li>
<li><p><strong>安装 Express：</strong> 在 <code>myapp</code> 目录内使用 npm 安装 Express 作为依赖：</p>
<pre><code>bashCopy code
npm install express --save
</code></pre></li>
<li><p><strong>创建 Express 应用：</strong> 在 <code>myapp</code> 目录内创建一个名为 <code>app.js</code> 的文件，并添加以下代码：</p>
<pre><code>javascriptCopy codeconst express = require(&#39;express&#39;);
const app = express();

// 定义一个路由，响应为 &quot;Hello World!&quot;
app.get(&#39;/&#39;, (req, res) =&gt; {
  res.send(&#39;Hello World!&#39;);
});

// 启动服务器并监听端口 3000
const port = 3000;
app.listen(port, () =&gt; {
  console.log(`服务器正在运行，端口号为 ${port}`);
});
</code></pre></li>
<li><p><strong>运行应用：</strong> 在终端中，仍然位于 <code>myapp</code> 目录内，使用以下命令启动应用程序：</p>
<pre><code>bashCopy code
node app.js
</code></pre></li>
<li><p><strong>在浏览器中访问应用：</strong> 打开你的网络浏览器，访问 <code>http://localhost:3000/</code> 以查看输出。你应该在页面上看到显示了 &quot;Hello World!&quot;。</p>
</li>
</ol>
<p>这个示例创建了一个基本的 Express 应用程序，它监听在端口 3000，并在通过网络浏览器访问时响应 &quot;Hello World!&quot;。使用 <code>express</code> 模块创建应用程序，定义路由，处理请求和响应。文本中解释了应用程序的行为，你可以在浏览器中访问和与应用程序交互，也可以在本地开发环境中运行提供的命令。</p>

          	</article>

			  <article class='markdown-body'>
            	<h2 id="express-">Express 应用程序生成器</h2>
<p>通过应用生成器工具 <code>express-generator</code> 可以快速创建一个应用的骨架。</p>
<p>你可以通过 <code>npx</code> （包含在 Node.js 8.2.0 及更高版本中）命令来运行 Express 应用程序生成器。</p>
<pre><code class="lang-console">$ npx express-generator
</code></pre>
<p>对于较老的 Node 版本，请通过 npm 将 Express 应用程序生成器安装到全局环境中并使用：</p>
<pre><code class="lang-console">$ npm install -g express-generator
$ express
</code></pre>
<p><code>-h</code> 参数可以列出所有可用的命令行参数：</p>
<pre><code class="lang-console">$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          输出使用方法
        --version       输出版本号
    -e, --ejs           添加对 ejs 模板引擎的支持
        --hbs           添加对 handlebars 模板引擎的支持
        --pug           添加对 pug 模板引擎的支持
    -H, --hogan         添加对 hogan.js 模板引擎的支持
        --no-view       创建不带视图引擎的项目
    -v, --view &lt;engine&gt; 添加对视图引擎（view） &lt;engine&gt; 的支持 (ejs|hbs|hjs|jade|pug|twig|vash) （默认是 jade 模板引擎）
    -c, --css &lt;engine&gt;  添加样式表引擎 &lt;engine&gt; 的支持 (less|stylus|compass|sass) （默认是普通的 css 文件）
        --git           添加 .gitignore
    -f, --force         强制在非空目录下创建
</code></pre>
<p>例如，如下命令创建了一个名称为 <em>myapp</em> 的 Express 应用。此应用将在当前目录下的 <em>myapp</em> 目录中创建，并且设置为使用 <a href="https://pugjs.org/">Pug</a> 模板引擎（view engine）：</p>
<pre><code class="lang-console">$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www
</code></pre>
<p>然后安装所有依赖包：</p>
<pre><code class="lang-console">$ cd myapp
$ npm install
</code></pre>
<p>在 MacOS 或 Linux 中，通过如下命令启动此应用：</p>
<pre><code class="lang-console">$ DEBUG=myapp:* npm start
</code></pre>
<p>在 Windows 命令行中，使用如下命令：</p>
<pre><code class="lang-console">&gt; set DEBUG=myapp:* &amp; npm start
</code></pre>
<p>在 Windows 的 PowerShell 中，使用如下命令：</p>
<pre><code class="lang-console">PS&gt; $env:DEBUG=&#39;myapp:*&#39;; npm start
</code></pre>
<p>然后在浏览器中打开 <code>http://localhost:3000/</code> 网址就可以看到这个应用了。</p>
<p>通过生成器创建的应用一般都有如下目录结构：</p>
<pre><code class="lang-console">.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files
</code></pre>
<p>通过 Express 应用生成器创建应用只是众多方法中的一种。你可以不使用它，也可以修改它让它符合你的需求。</p>

          	</article>

			  <article class='markdown-body'>
            	<h2 id="-">基本路由</h2>
<p>路由（Routing）指的是确定应用程序如何响应客户端对特定端点（即 URI 或路径）的请求，以及特定的 HTTP 请求方法（GET、POST 等）。</p>
<p>每个路由可以有一个或多个处理程序函数（handler functions），当匹配到路由时，这些处理程序函数将被执行。</p>
<p>路由定义的结构如下：</p>
<pre><code class="lang-javascript">app.METHOD(PATH, HANDLER)
</code></pre>
<p>其中：</p>
<ul>
<li><code>app</code> 是 express 的实例。</li>
<li><code>METHOD</code> 是一个小写的 HTTP 请求方法。</li>
<li><code>PATH</code> 是服务器上的路径。</li>
<li><code>HANDLER</code> 是在路由匹配时执行的函数。</li>
</ul>
<p>本教程假设已经创建了一个名为 <code>app</code> 的 express 实例，并且服务器正在运行。如果你对创建应用程序并启动它不熟悉，请查看 &quot;Hello World&quot; 示例。</p>
<p>以下示例演示了定义简单路由的方法。</p>
<p>在主页上响应 &quot;Hello World!&quot;：</p>
<pre><code class="lang-javascript">app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Hello World!&#39;)
})
</code></pre>
<p>响应根路由（/）上的 POST 请求，即应用程序的主页：</p>
<pre><code class="lang-javascript">app.post(&#39;/&#39;, function (req, res) {
  res.send(&#39;Got a POST request&#39;)
})
</code></pre>
<p>响应对 <code>/user</code> 路由的 PUT 请求：</p>
<pre><code class="lang-javascript">app.put(&#39;/user&#39;, function (req, res) {
  res.send(&#39;Got a PUT request at /user&#39;)
})
</code></pre>
<p>响应对 <code>/user</code> 路由的 DELETE 请求：</p>
<pre><code class="lang-javascript">app.delete(&#39;/user&#39;, function (req, res) {
  res.send(&#39;Got a DELETE request at /user&#39;)
})
</code></pre>
<p>有关路由的更多详细信息，请参阅路由指南。</p>

          	</article>

			  <article class='markdown-body'>
            	<h2 id="-express-">利用 Express 托管静态文件</h2>
<p>为了提供静态文件，如图像、CSS 文件和 JavaScript 文件，你可以使用 Express 框架中的 <code>express.static</code> 内置中间件函数。</p>
<p>该函数的特点如下：</p>
<pre><code class="lang-javascript">express.static(root, [options])
</code></pre>
<p>其中 <code>root</code> 参数指定要托管静态资产的根目录。要获取有关 <code>options</code> 参数的更多信息，请参阅 <code>express.static</code> 的文档。</p>
<p>例如，通过以下代码，你可以将位于 <code>public</code> 目录下的图像、CSS 文件和 JavaScript 文件对外开放访问：</p>
<pre><code class="lang-javascript">app.use(express.static(&#39;public&#39;))
</code></pre>
<p>现在，你可以访问 <code>public</code> 目录中的所有文件：</p>
<ul>
<li><a href="http://localhost:3000/images/kitten.jpg">http://localhost:3000/images/kitten.jpg</a></li>
<li><a href="http://localhost:3000/css/style.css">http://localhost:3000/css/style.css</a></li>
<li><a href="http://localhost:3000/js/app.js">http://localhost:3000/js/app.js</a></li>
<li><a href="http://localhost:3000/images/bg.png">http://localhost:3000/images/bg.png</a></li>
<li><a href="http://localhost:3000/hello.html">http://localhost:3000/hello.html</a></li>
</ul>
<p>Express 会在静态目录中查找文件，因此，在 URL 中不会出现存放静态文件的目录名。</p>
<p>如果要使用多个静态资源目录，请多次调用 <code>express.static</code> 中间件函数：</p>
<pre><code class="lang-javascript">app.use(express.static(&#39;public&#39;))
app.use(express.static(&#39;files&#39;))
</code></pre>
<p>访问静态资源文件时，<code>express.static</code> 中间件函数会根据目录添加的顺序查找所需的文件。</p>
<p>注意：为了获得最佳效果，建议使用反向代理缓存来提升提供静态资源的性能。</p>
<p>要为由 <code>express.static</code> 函数提供的文件创建一个虚拟路径前缀（实际上并不存在于文件系统中），可以为静态目录指定挂载路径，如下所示：</p>
<pre><code class="lang-javascript">app.use(&#39;/static&#39;, express.static(&#39;public&#39;))
</code></pre>
<p>现在，你可以通过带有 <code>/static</code> 前缀的路径来访问 <code>public</code> 目录中的文件：</p>
<ul>
<li><a href="http://localhost:3000/static/images/kitten.jpg">http://localhost:3000/static/images/kitten.jpg</a></li>
<li><a href="http://localhost:3000/static/css/style.css">http://localhost:3000/static/css/style.css</a></li>
<li><a href="http://localhost:3000/static/js/app.js">http://localhost:3000/static/js/app.js</a></li>
<li><a href="http://localhost:3000/static/images/bg.png">http://localhost:3000/static/images/bg.png</a></li>
<li><a href="http://localhost:3000/static/hello.html">http://localhost:3000/static/hello.html</a></li>
</ul>
<p>但是，提供给 <code>express.static</code> 函数的路径是相对于启动 Node 进程的目录的。如果你从另一个目录运行 Express 应用程序，最好使用要提供的目录的绝对路径：</p>
<pre><code class="lang-javascript">const path = require(&#39;path&#39;)
app.use(&#39;/static&#39;, express.static(path.join(__dirname, &#39;public&#39;)))
</code></pre>
<p>想要了解更多关于 <code>serve-static</code> 函数及其参数的信息，请参考 <code>serve-static</code> 文档。</p>

          	</article>

			  <article class='markdown-body'>
            	<h2 id="express-">Express 示例</h2>
<h3 id="-express-">本页面包含使用 Express 的示例列表。</h3>
<ul>
<li><a href="https://github.com/expressjs/express/tree/master/examples/auth">auth</a> - 带有登录和密码的身份验证</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/content-negotiation">content-negotiation</a> - HTTP 内容协商</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/cookie-sessions">cookie-sessions</a> - 使用基于 Cookie 的会话</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/cookies">cookies</a> - 使用 Cookies</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/downloads">downloads</a> - 将文件传输到客户端</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/ejs">ejs</a> - 使用嵌入式 JavaScript 模板引擎 (ejs)</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/error-pages">error-pages</a> - 创建错误页面</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/error">error</a> - 使用错误中间件</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/hello-world">hello-world</a> - 简单的请求处理程序</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/markdown">markdown</a> - Markdown 作为模板引擎</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/multi-router">multi-router</a> - 使用多个 Express 路由</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/multipart">multipart</a> - 接受多部分编码的表单数据</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/mvc">mvc</a> - MVC 风格的控制器</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/online">online</a> - 使用 <code>online</code> 和 <code>redis</code> 包跟踪在线用户活动</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/params">params</a> - 使用路由参数</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/resource">resource</a> - 在同一资源上执行多个 HTTP 操作</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/route-map">route-map</a> - 使用映射组织路由</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/route-middleware">route-middleware</a> - 使用路由中间件</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/route-separation">route-separation</a> - 根据每个资源组织路由</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/search">search</a> - 搜索 API</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/session">session</a> - 用户会话</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/static-files">static-files</a> - 提供静态文件</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/vhost">vhost</a> - 使用虚拟主机</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/view-constructor">view-constructor</a> - 动态渲染视图</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/view-locals">view-locals</a> - 在中间件调用之间在请求对象中保存数据</li>
<li><a href="https://github.com/expressjs/express/tree/master/examples/web-service">web-service</a> - 简单的 API 服务</li>
</ul>
<h3 id="-">其他示例</h3>
<p>以下是一些更广泛集成的附加示例。</p>
<p>警告：此信息涉及由 Expressjs 团队未维护的第三方站点、产品或模块。在此列出的信息并不构成 Expressjs 项目团队的认可或推荐。</p>
<ul>
<li><a href="https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-express">prisma-express-graphql</a> - 使用 <code>express-graphql</code> 创建的 GraphQL API，使用 <a href="https://www.npmjs.com/package/prisma">Prisma</a> 作为 ORM。</li>
<li><a href="https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nextjs-express">prisma-fullstack</a> - 使用 Next.js 创建的全栈应用，使用 <a href="https://www.npmjs.com/package/prisma">Prisma</a> 作为 ORM。</li>
<li><a href="https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-express">prisma-rest-api-js</a> - 使用 JavaScript 在 Express 中创建的 REST API，使用 <a href="https://www.npmjs.com/package/prisma">Prisma</a> 作为 ORM。</li>
<li><a href="https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-express">prisma-rest-api-ts</a> - 使用 TypeScript 在 Express 中创建的 REST API，使用 <a href="https://www.npmjs.com/package/prisma">Prisma</a> 作为 ORM。</li>
</ul>

          	</article>

			  <article class='markdown-body'>
				<h1 id="-">指南</h1>
            	<h2 id="-">路由</h2>
<p><strong>路由（Routing）</strong> 指的是应用程序的端点（URI）如何对客户端请求做出响应。如果需要对路由有一个简单的介绍，可以参考 <a href="https://www.expressjs.com.cn/en/starter/basic-routing.html">基本路由</a>。</p>
<p>你可以使用 Express 的 <code>app</code> 对象的方法来定义路由，这些方法与 HTTP 方法相对应；例如，使用 <code>app.get()</code> 来处理 GET 请求，使用 <code>app.post()</code> 来处理 POST 请求。完整的方法列表可以参考 <a href="https://www.expressjs.com.cn/en/4x/api.html#app.METHOD">app.METHOD</a>。你还可以使用 <a href="https://www.expressjs.com.cn/en/4x/api.html#app.all">app.all()</a> 处理所有的 HTTP 方法，并且可以使用 <a href="https://www.expressjs.com.cn/en/4x/api.html#app.use">app.use()</a> 来指定中间件作为回调函数（详见 <a href="https://www.expressjs.com.cn/en/guide/using-middleware.html">使用中间件</a>）。</p>
<p>这些路由方法会指定一个回调函数（有时称为“处理函数”），当应用程序接收到请求匹配指定的路由（端点）和 HTTP 方法时，会调用这个指定的回调函数。</p>
<p>事实上，这些路由方法可以有多个回调函数作为参数。如果有多个回调函数，需要在回调函数内提供 <code>next</code> 作为参数，然后在函数体内调用 <code>next()</code>，将控制权传递给下一个回调函数。</p>
<p>以下代码是一个非常基本的路由示例：</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;)
var app = express()

// 当收到 GET 请求时，回应 &quot;hello world&quot;
app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;hello world&#39;)
})
</code></pre>
<h3 id="-">路由方法</h3>
<p>路由方法派生自 HTTP 方法之一，它们会附加到 <code>express</code> 类的一个实例上。</p>
<p>以下代码是为 GET 和 POST 方法定义了一些路由，用于处理应用程序的根路径。</p>
<pre><code class="lang-javascript">// GET 方法的路由
app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;GET 请求到首页&#39;)
})

// POST 方法的路由
app.post(&#39;/&#39;, function (req, res) {
  res.send(&#39;POST 请求到首页&#39;)
})
</code></pre>
<p>Express 支持与所有 HTTP 请求方法相对应的方法：<code>get</code>、<code>post</code> 等等。完整的列表可以参考 <a href="https://www.expressjs.com.cn/en/4x/api.html#app.METHOD">app.METHOD</a>。</p>
<p>还有一个特殊的路由方法 <code>app.all()</code>，用于在一个路径上加载中间件函数，用于处理所有的 HTTP 请求方法。例如，下面的处理程序会对 &quot;/secret&quot; 路由进行处理，无论是使用 GET、POST、PUT、DELETE 还是其他 <a href="https://nodejs.org/api/http.html#http_http_methods">http 模块</a> 支持的 HTTP 请求方法。</p>
<pre><code class="lang-javascript">app.all(&#39;/secret&#39;, function (req, res, next) {
  console.log(&#39;访问了秘密部分 ...&#39;)
  next() // 将控制权传递给下一个处理程序
})
</code></pre>
<h3 id="-">路由路径</h3>
<p>路由路径与请求方法一起定义了可以进行请求的端点。路由路径可以是字符串、字符串模式或正则表达式。</p>
<p>字符 <code>?</code>、<code>+</code>、<code>*</code> 和 <code>()</code> 是它们对应的正则表达式子集。连字符 <code>-</code> 和点 <code>.</code> 在字符串路径中会被解释为文字。</p>
<p>如果你需要在路径字符串中使用美元符号 <code>$</code>，需要在 <code>([</code> 和 <code>])</code> 之间进行转义。例如，对于位于 &quot;/data/$book&quot; 的请求路径字符串，应该写作 &quot;/data/([\$])book&quot;。</p>
<p>Express 使用 <a href="https://www.npmjs.com/package/path-to-regexp">path-to-regexp</a> 来匹配路由路径；在定义路由路径时的所有可能性可以查看 path-to-regexp 文档。虽然 <a href="http://forbeslindesay.github.io/express-route-tester/">Express 路由测试器</a> 是一个用于测试基本 Express 路由的便</p>
<p>捷工具，但它不支持模式匹配。</p>
<p>查询字符串不是路由路径的一部分。</p>
<p>以下是基于字符串的路由路径的一些示例。</p>
<p>这个路由路径将匹配根路径 &quot;/&quot;:</p>
<pre><code class="lang-javascript">app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;根路径&#39;)
})
</code></pre>
<p>这个路由路径将匹配 &quot;/about&quot;:</p>
<pre><code class="lang-javascript">app.get(&#39;/about&#39;, function (req, res) {
  res.send(&#39;关于&#39;)
})
</code></pre>
<p>这个路由路径将匹配 &quot;/random.text&quot;:</p>
<pre><code class="lang-javascript">app.get(&#39;/random.text&#39;, function (req, res) {
  res.send(&#39;随机文本&#39;)
})
</code></pre>
<p>以下是基于字符串模式的路由路径示例。</p>
<p>这个路由路径将匹配 &quot;acd&quot; 和 &quot;abcd&quot;:</p>
<pre><code class="lang-javascript">app.get(&#39;/ab?cd&#39;, function (req, res) {
  res.send(&#39;ab?cd&#39;)
})
</code></pre>
<p>这个路由路径将匹配 &quot;abcd&quot;、&quot;abbcd&quot;、&quot;abbbcd&quot; 等等。</p>
<pre><code class="lang-javascript">app.get(&#39;/ab+cd&#39;, function (req, res) {
  res.send(&#39;ab+cd&#39;)
})
</code></pre>
<p>这个路由路径将匹配 &quot;abcd&quot;、&quot;abxcd&quot;、&quot;abRANDOMcd&quot;、&quot;ab123cd&quot; 等等。</p>
<pre><code class="lang-javascript">app.get(&#39;/ab*cd&#39;, function (req, res) {
  res.send(&#39;ab*cd&#39;)
})
</code></pre>
<p>这个路由路径将匹配 &quot;/abe&quot; 和 &quot;/abcde&quot;:</p>
<pre><code class="lang-javascript">app.get(&#39;/ab(cd)?e&#39;, function (req, res) {
  res.send(&#39;ab(cd)?e&#39;)
})
</code></pre>
<p>基于正则表达式的路由路径示例：</p>
<p>这个路由路径将匹配任何带有 &quot;a&quot; 的内容。</p>
<pre><code class="lang-javascript">app.get(/a/, function (req, res) {
  res.send(&#39;/a/&#39;)
})
</code></pre>
<p>这个路由路径将匹配 &quot;butterfly&quot; 和 &quot;dragonfly&quot;，但不会匹配 &quot;butterflyman&quot;、&quot;dragonflyman&quot; 等等。</p>
<pre><code class="lang-javascript">app.get(/.*fly$/, function (req, res) {
  res.send(&#39;/.*fly$/&#39;)
})
</code></pre>
<h3 id="-">路由参数</h3>
<p>路由参数是用于捕获 URL 中指定位置的命名 URL 段的值。捕获的值会填充到 <code>req.params</code> 对象中，其中路由参数的名称在路径中指定为它们各自的键。</p>
<pre><code>路由路径：/users/:userId/books/:bookId
请求 URL：http://localhost:3000/users/34/books/8989
req.params：{ &quot;userId&quot;: &quot;34&quot;, &quot;bookId&quot;: &quot;8989&quot; }
</code></pre><p>要在路由中定义具有路由参数的路由，请在路径的路由中指定路由参数，如下所示。</p>
<pre><code class="lang-javascript">app.get(&#39;/users/:userId/books/:bookId&#39;, function (req, res) {
  res.send(req.params)
})
</code></pre>
<p>路由参数的名称必须由 “单词字符”（[A-Za-z0-9_]）组成。</p>
<p>由于连字符（<code>-</code>）和点（<code>.</code>）会被解释为文字，因此它们可以与路由参数一起用于有用的目的。</p>
<pre><code>路由路径：/flights/:from-:to
请求 URL：http://localhost:3000/flights/LAX-SFO
req.params：{ &quot;from&quot;: &quot;LAX&quot;, &quot;to&quot;: &quot;SFO&quot; }
路由路径：/plantae/:genus.:species
请求 URL：http://localhost:3000/plantae/Prunus.persica
req.params：{ &quot;genus&quot;: &quot;Prunus&quot;, &quot;species&quot;: &quot;persica&quot; }
</code></pre><p>如果想要更精确地控制路由参数的匹配字符串，可以在括号 <code>()</code> 中添加正则表达式：</p>
<pre><code>路由路径：/user/:userId(\d+)
请求 URL：http://localhost:3000/user/42
req.params：{&quot;userId&quot;: &quot;42&quot;}
</code></pre><p>由于正则表达式通常是字符串的一部分，所以需要在 <code>\</code> 字符前添加额外的反斜杠，例如 <code>\\d+</code>。</p>
<p>在 Express 4.x 中，正则表达式中的 <code>*</code> 字符不会按照通常的方式进行解释，需要使用 <code>{0,}</code> 来代替 <code>*</code>。在 Express 5 中可能会修复这个问题。</p>
<h3 id="-">路由处理函数</h3>
<p>你可以提供多个回调函数来处理请求，这些回调函数的行为类似于<a href="https://www.expressjs.com.cn/en/guide/using-middleware.html">中间件</a>。唯一的例外是，这些回调函数可能会调用 <code>next(&#39;route&#39;)</code> 来跳过剩余的路由回调函数。你可以使用这种机制在一个路由上设置前置条件，然后如果没有必要继续执行当前路由，可以将控制权传递给下一个路由。</p>
<p>路由处理函数可以是一个函数、一个函数数组，或者它们的组合，如下面的示例所示。</p>
<p>一个单独的回调函数可以处理一个路由。例如：</p>
<pre><code class="lang-javascript">app.get(&#39;/example/a&#39;, function (req, res) {
  res.send(&#39;来自 A 的问候！&#39;)
})
</code></pre>
<p>多个回调函数可以处理一个路由（确保你指定了 <code>next</code> 对象）。例如：</p>
<pre><code class="lang-javascript">app.get(&#39;/example/b&#39;, function (req, res, next) {
  console.log(&#39;响应将由下一个函数处理 ...&#39;)
  next()
}, function (req, res) {
  res.send(&#39;来自 B 的问候！&#39;)
})
</code></pre>
<p>一个回调函数数组可以处理一个路由。例如：</p>
<pre><code class="lang-javascript">var cb0 = function (req, res, next) {
  console.log(&#39;CB0&#39;)
  next()
}

var cb1 = function (req, res, next) {
  console.log(&#39;CB1&#39;)
  next()
}

var cb2 = function (req, res) {
  res.send(&#39;来自 C 的问候！&#39;)
}

app.get(&#39;/example/c&#39;, [cb0, cb1, cb2])
</code></pre>
<p>独立函数和回调函数数组的组合可以处理一个路由。例如：</p>
<pre><code class="lang-javascript">var cb0 = function (req, res, next) {
  console.log(&#39;CB0&#39;)
  next()
}

var cb1 = function (req, res, next) {
  console.log(&#39;CB1&#39;)
  next()
}



app.get(&#39;/example/d&#39;, [cb0, cb1], function (req, res, next) {
  console.log(&#39;响应将由下一个函数处理 ...&#39;)
  next()
}, function (req, res) {
  res.send(&#39;来自 D 的问候！&#39;)
})
</code></pre>
<h3 id="-">响应方法</h3>
<p>在下表中，响应对象 <code>res</code> 的方法可以将响应发送给客户端，并终止请求-响应周期。如果在路由处理函数中没有调用这些方法之一，客户端请求将会被挂起。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.expressjs.com.cn/en/4x/api.html#res.download">res.download()</a></td>
<td>引导下载文件。</td>
</tr>
<tr>
<td><a href="https://www.expressjs.com.cn/en/4x/api.html#res.end">res.end()</a></td>
<td>结束响应过程。</td>
</tr>
<tr>
<td><a href="https://www.expressjs.com.cn/en/4x/api.html#res.json">res.json()</a></td>
<td>发送 JSON 响应。</td>
</tr>
<tr>
<td><a href="https://www.expressjs.com.cn/en/4x/api.html#res.jsonp">res.jsonp()</a></td>
<td>发送支持 JSONP 的 JSON 响应。</td>
</tr>
<tr>
<td><a href="https://www.expressjs.com.cn/en/4x/api.html#res.redirect">res.redirect()</a></td>
<td>重定向请求。</td>
</tr>
<tr>
<td><a href="https://www.expressjs.com.cn/en/4x/api.html#res.render">res.render()</a></td>
<td>渲染视图模板。</td>
</tr>
<tr>
<td><a href="https://www.expressjs.com.cn/en/4x/api.html#res.send">res.send()</a></td>
<td>发送各种类型的响应。</td>
</tr>
<tr>
<td><a href="https://www.expressjs.com.cn/en/4x/api.html#res.sendFile">res.sendFile()</a></td>
<td>以八位字节流的形式发送文件。</td>
</tr>
<tr>
<td><a href="https://www.expressjs.com.cn/en/4x/api.html#res.sendStatus">res.sendStatus()</a></td>
<td>设置响应状态码并将其字符串表示作为响应体发送。</td>
</tr>
</tbody>
</table>
<h3 id="app-route-">app.route()</h3>
<p>你可以使用 <code>app.route()</code> 来创建可链式处理路由路径的路由处理函数。因为路径在一个地方指定，创建模块化路由非常有帮助，可以减少冗余和错误。有关路由的更多信息，参见：<a href="https://www.expressjs.com.cn/en/4x/api.html#router">Router() 文档</a>。</p>
<p>以下是使用 <code>app.route()</code> 定义的链式路由处理函数的示例。</p>
<pre><code class="lang-javascript">app.route(&#39;/book&#39;)
  .get(function (req, res) {
    res.send(&#39;获取一本随机书籍&#39;)
  })
  .post(function (req, res) {
    res.send(&#39;添加一本书籍&#39;)
  })
  .put(function (req, res) {
    res.send(&#39;更新书籍&#39;)
  })
</code></pre>
<h3 id="express-router">express.Router</h3>
<p>使用 <code>express.Router</code> 类创建模块化、可挂载的路由处理函数。<code>Router</code> 实例是一个完整的中间件和路由系统；因此，它通常被称为“迷你应用程序”。</p>
<p>下面的示例创建了一个路由作为模块，加载了一个中间件函数，在其中定义了一些路由，并在主应用程序中的路径上挂载了这个路由模块。</p>
<p>在应用程序目录中创建一个名为 <code>birds.js</code> 的路由文件，内容如下：</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;)
var router = express.Router()

// 这个中间件只对这个路由有效
router.use(function timeLog (req, res, next) {
  console.log(&#39;Time: &#39;, Date.now())
  next()
})
// 定义主页路由
router.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;鸟类首页&#39;)
})
// 定义关于路由
router.get(&#39;/about&#39;, function (req, res) {
  res.send(&#39;关于鸟类&#39;)
})

module.exports = router
</code></pre>
<p>然后在应用程序中加载这个路由模块：</p>
<pre><code class="lang-javascript">var birds = require(&#39;./birds&#39;)

// ...

app.use(&#39;/birds&#39;, birds)
</code></pre>
<p>现在应用程序能够处理 <code>/birds</code> 和 <code>/birds/about</code> 的请求，同时还会调用特定于路由的 <code>timeLog</code> 中间件函数。</p>

          	</article>

			  <article class='markdown-body'>
				<h2 id="-">开发中间件</h2>
            	<h3 id="-express-">编写用于 Express 应用程序的中间件</h3>
<p><strong>中间件</strong>函数是具有访问应用程序请求-响应周期中的<a href="https://www.expressjs.com.cn/en/4x/api.html#req">请求对象</a>（<code>req</code>）、<a href="https://www.expressjs.com.cn/en/4x/api.html#res">响应对象</a>（<code>res</code>）和<code>next</code>函数的函数。<code>next</code>函数是 Express 路由器中的一个函数，当调用它时，它会执行当前中间件之后的中间件。</p>
<p>中间件函数可以执行以下任务：</p>
<ul>
<li>执行任何代码。</li>
<li>对请求和响应对象进行更改。</li>
<li>结束请求-响应周期。</li>
<li>调用堆栈中的下一个中间件。</li>
</ul>
<p>如果当前的中间件函数没有结束请求-响应周期，它必须调用<code>next()</code>将控制权传递给下一个中间件函数。否则，请求将会挂起。</p>
<p>以下图示显示了中间件函数调用的各个元素：</p>
<table>
<thead>
<tr>
<th><img src="https://www.expressjs.com.cn/images/express-mw.png" alt="img"></th>
<th>适用于中间件函数的 HTTP 方法。适用于中间件函数的路径（路由）。中间件函数的回调参数，按约定称为“next”。中间件函数的 HTTP 响应参数，按约定称为“res”。中间件函数的 HTTP 请求参数，按约定称为“req”。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>从 Express 5 开始，返回 Promise 的中间件函数在拒绝或抛出错误时将调用<code>next(value)</code>。<code>next</code>将以拒绝的值或抛出的错误调用。</p>
<h3 id="-">示例</h3>
<p>这是一个简单的“Hello World” Express 应用程序示例。本文的其余部分将定义并添加三个中间件函数到应用程序中：一个名为<code>myLogger</code>的函数，用于打印简单的日志消息；一个名为<code>requestTime</code>的函数，用于显示 HTTP 请求的时间戳；一个名为<code>validateCookies</code>的函数，用于验证传入的 cookies。</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;)
var app = express()

app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Hello World!&#39;)
})

app.listen(3000)
</code></pre>
<h4 id="-mylogger">中间件函数 <code>myLogger</code></h4>
<p>下面是一个名为“myLogger”的简单中间件函数示例。该函数在应用程序收到通过它的请求时只会打印“LOGGED”。这个中间件函数被赋值给名为 <code>myLogger</code> 的变量。</p>
<pre><code class="lang-javascript">var myLogger = function (req, res, next) {
  console.log(&#39;LOGGED&#39;)
  next()
}
</code></pre>
<p>请注意上面的<code>next()</code>调用。调用此函数会调用应用程序中的下一个中间件函数。<code>next()</code>函数不是 Node.js 或 Express API 的一部分，而是传递给中间件函数的第三个参数。<code>next()</code>函数的名称可以是任何名称，但按照约定，它总是被命名为“next”。为避免混淆，始终使用这个约定。</p>
<p>要加载中间件函数，请调用<code>app.use()</code>，并指定中间件函数。例如，以下代码在根路径（/）的路由之前加载了<code>myLogger</code>中间件函数。</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;)
var app = express()

var myLogger = function (req, res, next) {
  console.log(&#39;LOGGED&#39;)
  next()
}

app.use(myLogger)

app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Hello World!&#39;)
})

app.listen(3000)
</code></pre>
<p>每次应用程序收到请求时，它会在终端中打印消息“LOGGED”。</p>
<p>中间件加载的顺序很重要：加载的中间件函数越早，执行的顺序也越早。</p>
<p>如果在根路径的路由之后加载<code>myLogger</code>，请求将永远不会到达它，应用程序也不会打印“LOGGED”，因为根路径的路由处理程序会终止请求-响应周期。</p>
<p>中间件函数<code>myLogger</code>只是打印一条消息，然后通过调用<code>next()</code>函数将请求传递给堆栈中的下一个中间件函数。</p>
<h4 id="-requesttime">中间件函数 <code>requestTime</code></h4>
<p>接下来，我们将创建一个名为“requestTime”的中间件函数，并在请求对象上添加一个名为<code>requestTime</code>的属性。</p>
<pre><code class="lang-javascript">var requestTime = function (req, res, next) {
  req.requestTime = Date.now()
  next()
}
</code></pre>
<p>现在，应用程序使用<code>requestTime</code>中间件函数。此外，根路径路由的回调函数使用中间件函数添加到<code>req</code>（请求对象）的属性。</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;)
var app = express()

var requestTime = function (req, res, next) {
  req.requestTime = Date.now()
  next()
}

app.use(requestTime)

app.get(&#39;/&#39;, function (req, res) {
  var responseText = &#39;Hello World!&lt;br&gt;&#39;
  responseText += &#39;&lt;small&gt;Requested at: &#39; + req.requestTime + &#39;&lt;/small&gt;&#39;
  res.send(responseText)
})

app.listen(3000)
</code></pre>
<p>当您对应用程序的根目录发出请求时，应用程序会在浏览器中显示您的请求的时间戳。</p>
<h4 id="-validatecookies">中间件函数 <code>validateCookies</code></h4>
<p>最后，我们将创建一个中间件函数来验证传入的 cookies，并在 cookies 无效时发送 400 响应。</p>
<p>以下是一个验证 cookies 的示例函数，它使用外部异步服务。</p>
<pre><code class="lang-javascript">async function cookieValidator (cookies) {
  try {
    await externallyValidateCookie(cookies.testCookie)
  } catch {
    throw new Error(&#39;Invalid cookies&#39;)
  }
}
</code></pre>
<p>在这里，我们使用 <a href="https://www.expressjs.com.cn/resources/middleware/cookie-parser.html"><code>cookie-parser</code></a> 中间件来解析 <code>req</code> 对象上的传入 cookies，并将它们传递给我们的 <code>cookieValidator</code> 函数。<code>validateCookies</code> 中间件返回一个 Promise，如果被拒绝，将自动触发我们的错误处理程序。</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;)
var cookieParser = require

(&#39;cookie-parser&#39;)
var cookieValidator = require(&#39;./cookieValidator&#39;)

var app = express()

async function validateCookies (req, res, next) {
  await cookieValidator(req.cookies)
  next()
}

app.use(cookieParser())

app.use(validateCookies)

// 错误处理程序
app.use(function (err, req, res, next) {
  res.status(400).send(err.message)
})

app.listen(3000)
</code></pre>
<p>请注意，在<code>await cookieValidator(req.cookies)</code>之后调用了<code>next()</code>。这确保如果<code>cookieValidator</code>被解决，将调用堆栈中的下一个中间件。如果您将任何内容传递给<code>next()</code>函数（除了字符串<code>&#39;route&#39;</code>或<code>&#39;router&#39;</code>），Express 将视当前请求为错误，并将跳过任何剩余的非错误处理路由和中间件函数。</p>
<p>由于您可以访问请求对象、响应对象、堆栈中的下一个中间件函数以及整个 Node.js API，中间件函数的可能性是无限的。</p>
<p>有关 Express 中间件的更多信息，请参见：<a href="https://www.expressjs.com.cn/en/guide/using-middleware.html">使用 Express 中间件</a>。</p>
<h3 id="-">可配置的中间件</h3>
<p>如果您需要让您的中间件可配置，可以导出一个接受选项对象或其他参数的函数，然后根据输入参数返回中间件实现。</p>
<p>文件：<code>my-middleware.js</code></p>
<pre><code class="lang-javascript">module.exports = function (options) {
  return function (req, res, next) {
    // 基于选项对象实现中间件函数
    next()
  }
}
</code></pre>
<p>现在，可以像下面这样使用中间件。</p>
<pre><code class="lang-javascript">var mw = require(&#39;./my-middleware.js&#39;)

app.use(mw({ option1: &#39;1&#39;, option2: &#39;2&#39; }))
</code></pre>
<p>有关可配置的中间件的示例，请参考 <a href="https://github.com/expressjs/cookie-session">cookie-session</a> 和 <a href="https://github.com/expressjs/compression">compression</a>。</p>

          	</article>

			  <article class='markdown-body'>
            	<h2 id="-">使用中间件</h2>
<p>Express 是一个路由和中间件的 Web 框架，它本身具有最少的功能：一个 Express 应用程序实际上就是一系列的中间件函数调用。</p>
<p><strong>中间件</strong>函数是具有访问应用程序请求-响应周期中的<a href="https://www.expressjs.com.cn/en/4x/api.html#req">请求对象</a>（<code>req</code>）、<a href="https://www.expressjs.com.cn/en/4x/api.html#res">响应对象</a>（<code>res</code>）和下一个中间件函数的函数。下一个中间件函数通常用一个名为 <code>next</code> 的变量表示。</p>
<p>中间件函数可以执行以下任务：</p>
<ul>
<li>执行任何代码。</li>
<li>对请求和响应对象进行更改。</li>
<li>结束请求-响应周期。</li>
<li>调用堆栈中的下一个中间件函数。</li>
</ul>
<p>如果当前的中间件函数没有结束请求-响应周期，它必须调用 <code>next()</code> 将控制权传递给下一个中间件函数。否则，请求将会悬挂。</p>
<p>Express 应用程序可以使用以下类型的中间件：</p>
<ul>
<li><a href="https://www.expressjs.com.cn/guide/using-middleware.html#middleware.application">应用程序级中间件</a></li>
<li><a href="https://www.expressjs.com.cn/guide/using-middleware.html#middleware.router">路由器级中间件</a></li>
<li><a href="https://www.expressjs.com.cn/guide/using-middleware.html#middleware.error-handling">错误处理中间件</a></li>
<li><a href="https://www.expressjs.com.cn/guide/using-middleware.html#middleware.built-in">内置中间件</a></li>
<li><a href="https://www.expressjs.com.cn/guide/using-middleware.html#middleware.third-party">第三方中间件</a></li>
</ul>
<p>您可以为应用程序级和路由器级中间件加载可选的挂载路径。您还可以一次加载一系列中间件函数，这在挂载点创建了中间件系统的子堆栈。</p>
<h3 id="-">应用程序级中间件</h3>
<p>使用 <code>app.use()</code> 和 <code>app.METHOD()</code> 函数将应用程序级中间件绑定到 <a href="https://www.expressjs.com.cn/en/4x/api.html#app">app 对象</a> 的实例上，其中 <code>METHOD</code> 是中间件函数处理的请求的 HTTP 方法（例如 GET、PUT 或 POST）的小写形式。</p>
<p>以下示例展示了一个没有挂载路径的中间件函数。每次应用程序接收到请求时，该函数都会被执行。</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;)
var app = express()

app.use(function (req, res, next) {
  console.log(&#39;Time:&#39;, Date.now())
  next()
})
</code></pre>
<p>以下示例展示了一个挂载在 <code>/user/:id</code> 路径上的中间件函数。该函数会为 <code>/user/:id</code> 路径上的任何类型的 HTTP 请求执行。</p>
<pre><code class="lang-javascript">app.use(&#39;/user/:id&#39;, function (req, res, next) {
  console.log(&#39;Request Type:&#39;, req.method)
  next()
})
</code></pre>
<p>以下示例展示了一个路由和其处理程序函数（中间件系统）。该函数会处理对 <code>/user/:id</code> 路径的 GET 请求。</p>
<pre><code class="lang-javascript">app.get(&#39;/user/:id&#39;, function (req, res, next) {
  res.send(&#39;USER&#39;)
})
</code></pre>
<p>以下是一个在挂载点加载一系列中间件函数的示例，带有挂载路径。它展示了一个中间件子堆栈，为任何类型的 HTTP 请求到 <code>/user/:id</code> 路径打印请求信息。</p>
<pre><code class="lang-javascript">app.use(&#39;/user/:id&#39;, function (req, res, next) {
  console.log(&#39;Request URL:&#39;, req.originalUrl)
  next()
}, function (req, res, next) {
  console.log(&#39;Request Type:&#39;, req.method)
  next()
})
</code></pre>
<p>路由处理程序使您能够为一个路径定义多个路由。以下示例为 <code>/user/:id</code> 路径的 GET 请求定义了两个路由。第二个路由不会引起任何问题，但它永远不会被调用，因为第一个路由结束了请求-响应周期。</p>
<p>以下示例展示了一个中间件子堆栈，处理对 <code>/user/:id</code> 路径的 GET 请求。</p>
<pre><code class="lang-javascript">app.get(&#39;/user/:id&#39;, function (req, res, next) {
  console.log(&#39;ID:&#39;, req.params.id)
  next()
}, function (req, res, next) {
  res.send(&#39;User Info&#39;)
})

// 用于处理 /user/:id 路径的处理程序，会打印用户 ID
app.get(&#39;/user/:id&#39;, function (req, res, next) {
  res.send(req.params.id)
})
</code></pre>
<p>要跳过路由器中间件堆栈中的其余部分，可以调用 <code>next(&#39;route&#39;)</code> 将控制权传递给下一个路由。<strong>注意</strong>：<code>next(&#39;route&#39;)</code> 仅适用于通过使用 <code>app.METHOD()</code> 或 <code>router.METHOD()</code> 函数加载的中间件函数。</p>
<p>以下示例展示了一个中间件子堆栈，处理对 <code>/user/:id</code> 路径的 GET 请求。</p>
<pre><code class="lang-javascript">app.get(&#39;/user/:id&#39;, function (req, res, next) {
  // 如果用户 ID 是 0，则跳转到下一个路由
  if (req.params.id === &#39;0&#39;) next(&#39;route&#39;)
  // 否则将控制权传递给此堆栈中的下一个中间件函数
  else next()
}, function (req, res, next) {
  // 发送常规响应
  res.send(&#39;regular&#39;)
})

// 用于处理 /user/:id 路径的处理程序，会发送特殊响应
app.get(&#39;/user/:id&#39;, function (req, res, next) {
  res.send(&#39;special&#39;)
})
</code></pre>
<p>中间件还可以在数组中声明，以实现可重用性。</p>
<p>以下示例展示了一个中间件子堆栈的数组，处理对 <code>/user/:id</code> 路径的 GET 请求。</p>
<pre><code class="lang-javascript">function logOriginalUrl (req, res, next) {
  console.log(&#39;Request URL:&#39;, req.originalUrl)
  next()
}

function logMethod (req, res, next) {
  console.log(&#39;Request Type:&#39;, req.method)
  next()
}

var logStuff =

 [logOriginalUrl, logMethod]
app.get(&#39;/user/:id&#39;, logStuff, function (req, res, next) {
  res.send(&#39;User Info&#39;)
})
</code></pre>
<h3 id="-">路由器级中间件</h3>
<p>路由器级中间件的工作方式与应用程序级中间件相同，只不过它绑定到 <code>express.Router()</code> 的实例上。</p>
<pre><code class="lang-javascript">var router = express.Router()
</code></pre>
<p>使用 <code>router.use()</code> 和 <code>router.METHOD()</code> 函数加载路由器级中间件。</p>
<p>下面的示例代码通过使用路由器级中间件来复制上面展示的应用程序级中间件的中间件系统：</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;)
var app = express()
var router = express.Router()

// 一个没有挂载路径的中间件函数。该代码对路由器的每个请求都会被执行
router.use(function (req, res, next) {
  console.log(&#39;Time:&#39;, Date.now())
  next()
})

// 一个中间件子堆栈，为 /user/:id 路径上的任何类型的 HTTP 请求执行
router.use(&#39;/user/:id&#39;, function (req, res, next) {
  console.log(&#39;Request URL:&#39;, req.originalUrl)
  next()
}, function (req, res, next) {
  console.log(&#39;Request Type:&#39;, req.method)
  next()
})

// 一个中间件子堆栈，处理对 /user/:id 路径的 GET 请求
router.get(&#39;/user/:id&#39;, function (req, res, next) {
  // 如果用户 ID 是 0，则跳转到下一个路由
  if (req.params.id === &#39;0&#39;) next(&#39;route&#39;)
  // 否则将控制权传递给此堆栈中的下一个中间件函数
  else next()
}, function (req, res, next) {
  // 渲染常规页面
  res.render(&#39;regular&#39;)
})

// 用于处理 /user/:id 路径的处理程序，会渲染特殊页面
router.get(&#39;/user/:id&#39;, function (req, res, next) {
  console.log(req.params.id)
  res.render(&#39;special&#39;)
})

// 将路由器挂载到应用程序上
app.use(&#39;/&#39;, router)
</code></pre>
<p>要跳过路由器的其余中间件函数，可以调用 <code>next(&#39;router&#39;)</code> 将控制权传递回路由器实例。</p>
<p>以下示例展示了一个中间件子堆栈，处理对 <code>/user/:id</code> 路径的 GET 请求。</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;)
var app = express()
var router = express.Router()

// 用检查条件限定路由器，并在需要时退出
router.use(function (req, res, next) {
  if (!req.headers[&#39;x-auth&#39;]) return next(&#39;router&#39;)
  next()
})

router.get(&#39;/user/:id&#39;, function (req, res) {
  res.send(&#39;hello, user!&#39;)
})

// 使用路由器并对通过的请求进行 401 处理
app.use(&#39;/admin&#39;, router, function (req, res) {
  res.sendStatus(401)
})
</code></pre>
<h3 id="-">错误处理中间件</h3>
<p>错误处理中间件始终有 <em>四个</em> 参数。您必须提供四个参数来将其标识为错误处理中间件函数。即使您不需要使用 <code>next</code> 对象，您也必须指定它以保持签名。否则，<code>next</code> 对象将被解释为常规中间件，将无法处理错误。</p>
<p>与其他中间件函数一样定义错误处理中间件函数，只是参数变为四个而不是三个，具体来说是 <code>(err, req, res, next)</code> 的签名：</p>
<pre><code class="lang-javascript">app.use(function (err, req, res, next) {
  console.error(err.stack)
  res.status(500).send(&#39;Something broke!&#39;)
})
</code></pre>
<p>有关错误处理中间件的详细信息，请参见：<a href="https://www.expressjs.com.cn/en/guide/error-handling.html">错误处理</a>。</p>
<h3 id="-">内置中间件</h3>
<p>从版本 4.x 开始，Express 不再依赖于 <a href="https://github.com/senchalabs/connect">Connect</a>。先前包含在 Express 中的中间件函数现在在单独的模块中；请参见<a href="https://github.com/senchalabs/connect#middleware">中间件函数列表</a>。</p>
<p>Express 具有以下内置的中间件函数：</p>
<ul>
<li><a href="https://www.expressjs.com.cn/en/4x/api.html#express.static">express.static</a> 用于提供静态资源，如 HTML 文件、图像等。</li>
<li><a href="https://www.expressjs.com.cn/en/4x/api.html#express.json">express.json</a> 用于解析带有 JSON 负载的传入请求。<strong>注意：仅适用于 Express 4.16.0+</strong></li>
<li><a href="https://www.expressjs.com.cn/en/4x/api.html#express.urlencoded">express.urlencoded</a> 用于解析带有 URL 编码负载的传入请求。<strong>注意：仅适用于 Express 4.16.0+</strong></li>
</ul>
<h3 id="-">第三方中间件</h3>
<p>使用第三方中间件向 Express 应用程序添加功能。</p>
<p>安装所需功能的 Node.js 模块，然后在应用程序级别或路由器级别加载它。</p>
<p>以下示例说明了如何安装和加载解析 cookie 的中间件函数 <code>cookie-parser</code>：</p>
<pre><code class="lang-console">$ npm install cookie-parser
var express = require(&#39;express&#39;)
var app = express()
var cookieParser = require(&#39;cookie-parser&#39;)

// 加载解析 cookie 的中间件
app.use(cookieParser())
</code></pre>
<p>有关常与 Express 一起使用的第三方中间件函数的部分列表，请参见：<a href="https://www.expressjs.com.cn/resources/middleware.html">第三方中间件</a>。</p>

          	</article>

			  <article class='markdown-body'>
            	<h2 id="-express-api">覆盖 Express API</h2>
<p>Express API 包含了请求和响应对象上的各种方法和属性。这些是通过原型继承的。Express API 有两个扩展点：</p>
<ol>
<li>全局原型在 <code>express.request</code> 和 <code>express.response</code> 上。</li>
<li>应用程序特定的原型在 <code>app.request</code> 和 <code>app.response</code> 上。</li>
</ol>
<p>更改全局原型将影响同一进程中加载的所有 Express 应用程序。如果需要，可以通过在创建新应用程序后仅更改应用程序特定的原型来进行应用程序特定的更改。</p>
<h3 id="-">方法</h3>
<p>您可以通过分配自定义函数来覆盖现有方法的签名和行为。</p>
<p>以下是覆盖 <a href="https://www.expressjs.com.cn/4x/api.html#res.sendStatus">res.sendStatus</a> 行为的示例。</p>
<pre><code class="lang-javascript">app.response.sendStatus = function (statusCode, type, message) {
  // 代码故意保持简单，仅用于演示目的
  return this.contentType(type)
    .status(statusCode)
    .send(message)
}
</code></pre>
<p>上述实现完全改变了 <code>res.sendStatus</code> 的原始签名。它现在接受状态码、编码类型和要发送到客户端的消息。</p>
<p>现在可以这样使用覆盖的方法：</p>
<pre><code class="lang-javascript">res.sendStatus(404, &#39;application/json&#39;, &#39;{&quot;error&quot;:&quot;resource not found&quot;}&#39;)
</code></pre>
<h3 id="-">属性</h3>
<p>Express API 中的属性要么是：</p>
<ol>
<li>分配的属性（例如：<code>req.baseUrl</code>、<code>req.originalUrl</code>）</li>
<li>定义为 getter（例如：<code>req.secure</code>、<code>req.ip</code>）</li>
</ol>
<p>由于第一类属性是在当前请求-响应周期的上下文中动态分配到 <code>request</code> 和 <code>response</code> 对象上的，它们的行为无法被覆盖。</p>
<p>第二类属性可以通过 Express API 扩展 API 进行覆盖。</p>
<p>以下代码重新定义了如何派生 <code>req.ip</code> 的值。现在，它只是返回 <code>Client-IP</code> 请求头的值。</p>
<pre><code class="lang-javascript">Object.defineProperty(app.request, &#39;ip&#39;, {
  configurable: true,
  enumerable: true,
  get: function () { return this.get(&#39;Client-IP&#39;) }
})
</code></pre>

          	</article>

			  <article class='markdown-body'>
            	<h2 id="-express-">在 Express 中使用模板引擎</h2>
<p><em>模板引擎</em> 可以让您在应用程序中使用静态的模板文件。在运行时，模板引擎会将模板文件中的变量替换为实际的值，并将模板转换为发送给客户端的 HTML 文件。这种方法使得设计 HTML 页面更加容易。</p>
<p>一些在 Express 中常用的模板引擎包括 <a href="https://pugjs.org/api/getting-started.html">Pug</a>、<a href="https://www.npmjs.com/package/mustache">Mustache</a> 和 <a href="https://www.npmjs.com/package/ejs">EJS</a>。<a href="https://www.expressjs.com.cn/en/starter/generator.html">Express 应用程序生成器</a> 默认使用 <a href="https://www.npmjs.com/package/jade">Jade</a> 作为其默认模板引擎，但也支持其他几种模板引擎。</p>
<p>您可以查看 <a href="https://github.com/expressjs/express/wiki#template-engines">Template Engines (Express wiki)</a> 以获取可以与 Express 一起使用的模板引擎列表。还可以参考 <a href="https://strongloop.com/strongblog/compare-javascript-templates-jade-mustache-dust/">比较 JavaScript 模板引擎：Jade、Mustache、Dust 等等</a>。</p>
<p><strong>注意</strong>：Jade 已经更名为 <a href="https://www.npmjs.com/package/pug">Pug</a>。您仍然可以在应用程序中继续使用 Jade，它将正常工作。但是，如果您想要获得模板引擎的最新更新，您需要将应用程序中的 Jade 替换为 Pug。</p>
<p>要渲染模板文件，请设置以下<a href="https://www.expressjs.com.cn/en/4x/api.html#app.set">应用程序设置属性</a>，这些属性应设置在生成器创建的默认应用程序中的 <code>app.js</code> 文件中：</p>
<ul>
<li><code>views</code>，模板文件所在的目录。例如：<code>app.set(&#39;views&#39;, &#39;./views&#39;)</code>。默认情况下，这将指向应用程序根目录中的 <code>views</code> 目录。</li>
<li><code>view engine</code>，要使用的模板引擎。例如，要使用 Pug 模板引擎：<code>app.set(&#39;view engine&#39;, &#39;pug&#39;)</code>。</li>
</ul>
<p>然后安装相应的模板引擎 npm 包；例如，安装 Pug：</p>
<pre><code class="lang-console">$ npm install pug --save
</code></pre>
<p>符合 Express 规范的模板引擎，如 Jade 和 Pug，会导出一个名为 <code>__express(filePath, options, callback)</code> 的函数，该函数由 <code>res.render()</code> 函数调用以渲染模板代码。</p>
<p>某些模板引擎不遵循这个约定。<a href="https://www.npmjs.org/package/consolidate">Consolidate.js</a> 库遵循这个约定，通过映射所有流行的 Node.js 模板引擎，因此在 Express 内部可以无缝使用。</p>
<p>在设置了视图引擎之后，您无需在应用程序中指定引擎或加载模板引擎模块；Express 会在内部加载模块，如下所示（对于上述示例）。</p>
<pre><code class="lang-javascript">app.set(&#39;view engine&#39;, &#39;pug&#39;)
</code></pre>
<p>在 <code>views</code> 目录中创建一个名为 <code>index.pug</code> 的 Pug 模板文件，内容如下：</p>
<pre><code class="lang-pug">html
  head
    title= title
  body
    h1= message
</code></pre>
<p>然后创建一个路由来渲染 <code>index.pug</code> 文件。如果未设置 <code>view engine</code> 属性，则必须指定 <code>view</code> 文件的扩展名。否则，您可以省略它。</p>
<pre><code class="lang-javascript">app.get(&#39;/&#39;, function (req, res) {
  res.render(&#39;index&#39;, { title: &#39;Hey&#39;, message: &#39;Hello there!&#39; })
})
</code></pre>
<p>当您对主页发出请求时，<code>index.pug</code> 文件将被渲染为 HTML。</p>
<p>注意：视图引擎缓存不会缓存模板输出的内容，只会缓存底层的模板本身。即使缓存开启，视图仍会在每次请求时重新渲染。</p>
<p>要了解更多关于 Express 中模板引擎的工作原理，请参阅：<a href="https://www.expressjs.com.cn/en/advanced/developing-template-engines.html">“为 Express 开发模板引擎”</a>。</p>

          	</article>

			  <article class='markdown-body'>
            	<h2 id="-">错误处理</h2>
<p><em>错误处理</em> 是指 Express 如何捕获和处理同步和异步发生的错误。Express 默认提供了错误处理程序，因此您无需编写自己的错误处理程序即可开始使用。</p>
<h3 id="-">捕获错误</h3>
<p>确保 Express 捕获在运行路由处理程序和中间件期间发生的所有错误是很重要的。</p>
<p>同步代码中发生的错误在路由处理程序和中间件内部不需要额外的工作。如果同步代码抛出错误，Express 将会捕获和处理它。例如：</p>
<pre><code class="lang-javascript">app.get(&#39;/&#39;, function (req, res) {
  throw new Error(&#39;BROKEN&#39;) // Express 会自行捕获这个错误。
})
</code></pre>
<p>对于从路由处理程序和中间件调用的异步函数返回的错误，您必须将它们传递给 <code>next()</code> 函数，Express 将会捕获和处理它们。例如：</p>
<pre><code class="lang-javascript">app.get(&#39;/&#39;, function (req, res, next) {
  fs.readFile(&#39;/file-does-not-exist&#39;, function (err, data) {
    if (err) {
      next(err) // 将错误传递给 Express。
    } else {
      res.send(data)
    }
  })
})
</code></pre>
<p>从 Express 5 开始，当路由处理程序和中间件返回一个 Promise 时，如果它们拒绝或抛出错误，将会自动调用 <code>next(value)</code>。例如：</p>
<pre><code class="lang-javascript">app.get(&#39;/user/:id&#39;, async function (req, res, next) {
  var user = await getUserById(req.params.id)
  res.send(user)
})
</code></pre>
<p>如果 <code>getUserById</code> 抛出错误或拒绝，<code>next</code> 将会被调用，传递抛出的错误或拒绝的值。如果未提供拒绝的值，<code>next</code> 将会被调用，并使用 Express 路由器提供的默认错误对象。</p>
<p>如果您将任何内容传递给 <code>next()</code> 函数（除了字符串 <code>&#39;route&#39;</code>），Express 将视当前请求为错误，并跳过任何剩余的非错误处理路由和中间件函数。</p>
<p>如果在一个序列的回调中没有提供数据，只有错误，您可以简化这段代码如下：</p>
<pre><code class="lang-javascript">app.get(&#39;/&#39;, [
  function (req, res, next) {
    fs.writeFile(&#39;/inaccessible-path&#39;, &#39;data&#39;, next)
  },
  function (req, res) {
    res.send(&#39;OK&#39;)
  }
])
</code></pre>
<p>在上面的示例中，<code>next</code> 被作为 <code>fs.writeFile</code> 的回调提供，无论是否有错误都会被调用。如果没有错误，则执行第二个处理程序；否则，Express 会捕获并处理错误。</p>
<p>必须捕获由路由处理程序或中间件调用的异步代码中发生的错误，并将它们传递给 Express 进行处理。例如：</p>
<pre><code class="lang-javascript">app.get(&#39;/&#39;, function (req, res, next) {
  setTimeout(function () {
    try {
      throw new Error(&#39;BROKEN&#39;)
    } catch (err) {
      next(err)
    }
  }, 100)
})
</code></pre>
<p>上面的示例使用了 <code>try...catch</code> 块来捕获异步代码中的错误，并将它们传递给 Express。如果省略了 <code>try...catch</code> 块，Express 将不会捕获错误，因为它不是同步处理程序代码的一部分。</p>
<p>使用 Promises 可以避免 <code>try...catch</code> 块的开销，或者在使用返回 Promises 的函数时使用。例如：</p>
<pre><code class="lang-javascript">app.get(&#39;/&#39;, function (req, res, next) {
  Promise.resolve().then(function () {
    throw new Error(&#39;BROKEN&#39;)
  }).catch(next) // 错误将会传递给 Express。
})
</code></pre>
<p>由于 Promises 自动捕获同步错误和拒绝的 Promises，因此您可以简单地将 <code>next</code> 作为最终的 catch 处理程序，Express 将会捕获错误，因为 catch 处理程序将错误作为第一个参数。</p>
<p>您还可以使用一系列处理程序来依赖于同步错误捕获，将异步代码简化为一些微不足道的内容。例如：</p>
<pre><code class="lang-javascript">app.get(&#39;/&#39;, [
  function (req, res, next) {
    fs.readFile(&#39;/maybe-valid-file&#39;, &#39;utf-8&#39;, function (err, data) {
      res.locals.data = data
      next(err)
    })
  },
  function (req, res) {
    res.locals.data = res.locals.data.split(&#39;,&#39;)[1]
    res.send(res.locals.data)
  }
])
</code></pre>
<p>上面的示例从 <code>readFile</code> 调用中提取了几个微不足道的语句。如果 <code>readFile</code> 引发错误，则将错误传递给 Express，否则您将迅速返回到链中的下一个处理程序中的同步错误处理领域。然后，上面的示例尝试处理数据。如果失败，则同步错误处理程序将捕获它。如果您在 <code>readFile</code> 回调内部执行此处理，则应用程序可能会退出，Express 错误处理程序将不会运行。</p>
<p>无论使用哪种方法，如果您希望 Express 错误处理程序被调用并且应用程序继续运行，您必须确保 Express 接收到错误。</p>
<h3 id="-">默认错误处理程序</h3>
<p>Express 自带了一个内置的错误处理程序，用于处理应用中可能遇到的任何错误。这个默认的错误处理中间件函数被添加到中间件函数栈的末尾。</p>
<p>如果将错误传递给 <code>next()</code>，并且您没有在自定义错误处理程序中处理它，它将由内置的错误处理程序处理；错误将被写入客户端，并附带堆栈跟踪。在生产环境中，堆栈跟踪不会包含在内。</p>
<p>将环境变量 <code>NODE_ENV</code> 设置为 <code>production</code>，以在生产模式下运行应用程序。</p>
<p>当写入错误时，以下信息将添加到响应中：</p>
<ul>
<li><code>res.statusCode</code> 从 <code>err.status</code>（或 <code>err.statusCode</code>）</li>
</ul>
<p>设置。如果该值超出 4xx 或 5xx 范围，将会被设置为 500。</p>
<ul>
<li><code>res.statusMessage</code> 根据状态码设置。</li>
<li>在生产环境中，响应的主体将是状态码消息的 HTML，否则将是 <code>err.stack</code>。</li>
<li>在一个 <code>err.headers</code> 对象中指定的任何标头。</li>
</ul>
<p>如果在开始写入响应后（例如，在将响应流式传输给客户端时）通过 <code>next()</code> 调用错误，Express 默认的错误处理程序将关闭连接并失败请求。</p>
<p>因此，当添加自定义错误处理程序时，您必须在头部已经发送到客户端时委托给默认的 Express 错误处理程序：</p>
<pre><code class="lang-javascript">function errorHandler (err, req, res, next) {
  if (res.headersSent) {
    return next(err)
  }
  res.status(500)
  res.render(&#39;error&#39;, { error: err })
}
</code></pre>
<p>请注意，如果在代码中多次使用 <code>next()</code> 调用错误，则默认错误处理程序可能会被触发，即使存在自定义错误处理中间件。</p>
<h3 id="-">编写错误处理程序</h3>
<p>与其他中间件函数一样，可以按照相同的方式定义错误处理中间件函数，只是错误处理函数有四个参数，而不是三个：<code>(err, req, res, next)</code>。例如：</p>
<pre><code class="lang-javascript">app.use(function (err, req, res, next) {
  console.error(err.stack)
  res.status(500).send(&#39;Something broke!&#39;)
})
</code></pre>
<p>您可以在最后定义错误处理中间件，放在其他的 <code>app.use()</code> 和路由调用之后。例如：</p>
<pre><code class="lang-javascript">var bodyParser = require(&#39;body-parser&#39;)
var methodOverride = require(&#39;method-override&#39;)

app.use(bodyParser.urlencoded({
  extended: true
}))
app.use(bodyParser.json())
app.use(methodOverride())
app.use(function (err, req, res, next) {
  // 逻辑
})
</code></pre>
<p>在中间件函数内部的响应可以是任何格式，例如 HTML 错误页面、简单消息或 JSON 字符串。</p>
<p>出于组织（和更高级的框架）目的，您可以定义多个错误处理中间件函数，就像您对常规中间件函数所做的那样。例如，要为使用 <code>XHR</code> 和不使用 <code>XHR</code> 的请求定义错误处理程序：</p>
<pre><code class="lang-javascript">var bodyParser = require(&#39;body-parser&#39;)
var methodOverride = require(&#39;method-override&#39;)

app.use(bodyParser.urlencoded({
  extended: true
}))
app.use(bodyParser.json())
app.use(methodOverride())
app.use(logErrors)
app.use(clientErrorHandler)
app.use(errorHandler)
</code></pre>
<p>在这个示例中，通用的 <code>logErrors</code> 可能会将请求和错误信息写入到 <code>stderr</code>，例如：</p>
<pre><code class="lang-javascript">function logErrors (err, req, res, next) {
  console.error(err.stack)
  next(err)
}
</code></pre>
<p>同样在这个示例中，<code>clientErrorHandler</code> 被定义如下；在这种情况下，错误被明确地传递给下一个处理程序。</p>
<p>请注意，在错误处理函数中不调用“next”时，您负责编写（并结束）响应。否则，这些请求将会“挂起”，并且不会被垃圾回收。</p>
<pre><code class="lang-javascript">function clientErrorHandler (err, req, res, next) {
  if (req.xhr) {
    res.status(500).send({ error: &#39;Something failed!&#39; })
  } else {
    next(err)
  }
}
</code></pre>
<p>将“catch-all” <code>errorHandler</code> 函数实现如下（例如）：</p>
<pre><code class="lang-javascript">function errorHandler (err, req, res, next) {
  res.status(500)
  res.render(&#39;error&#39;, { error: err })
}
</code></pre>
<p>如果您的路由处理程序具有多个回调函数，您可以使用 <code>route</code> 参数跳过到下一个路由处理程序。例如：</p>
<pre><code class="lang-javascript">app.get(&#39;/a_route_behind_paywall&#39;,
  function checkIfPaidSubscriber (req, res, next) {
    if (!req.user.hasPaid) {
      // 继续处理这个请求
      next(&#39;route&#39;)
    } else {
      next()
    }
  }, function getPaidContent (req, res, next) {
    PaidContent.find(function (err, doc) {
      if (err) return next(err)
      res.json(doc)
    })
  })
</code></pre>
<p>在这个例子中，<code>getPaidContent</code> 处理程序将被跳过</p>
<p>，但是任何在 <code>/a_route_behind_paywall</code> 路由下的剩余处理程序都会继续执行。</p>
<p>调用 <code>next()</code> 和 <code>next(err)</code> 表示当前处理程序已完成以及处于什么状态。<code>next(err)</code> 将跳过除已设置为处理错误的处理程序之外的所有剩余处理程序链。</p>

          	</article>

			  <article class='markdown-body'>
            	<h2 id="express-">Express 调试</h2>
<p>Express 内部使用 <a href="https://www.npmjs.com/package/debug">debug</a> 模块来记录有关路由匹配、使用中的中间件函数、应用程序模式以及请求-响应周期流程的信息。</p>
<p><code>debug</code> 类似于增强版的 <code>console.log</code>，但与 <code>console.log</code> 不同的是，在生产代码中不需要注释掉 <code>debug</code> 日志。日志记录默认处于关闭状态，并且可以通过使用 <code>DEBUG</code> 环境变量有条件地打开。</p>
<p>要查看 Express 中使用的所有内部日志，请在启动应用程序时将 <code>DEBUG</code> 环境变量设置为 <code>express:*</code>。</p>
<pre><code class="lang-console">$ DEBUG=express:* node index.js
</code></pre>
<p>在 Windows 上，使用相应的命令。</p>
<pre><code class="lang-console">&gt; set DEBUG=express:* &amp; node index.js
</code></pre>
<p>在使用 <a href="https://www.expressjs.com.cn/en/starter/generator.html">express generator</a> 生成的默认应用程序上运行此命令会打印出以下输出：</p>
<pre><code class="lang-console">$ DEBUG=express:* node ./bin/www
  express:router:route new / +0ms
  express:router:layer new / +1ms
  express:router:route get / +1ms
  express:router:layer new / +0ms
  express:router:route new / +1ms
  express:router:layer new / +0ms
  express:router:route get / +0ms
  express:router:layer new / +0ms
  express:application compile etag weak +1ms
  express:application compile query parser extended +0ms
  express:application compile trust proxy false +0ms
  express:application booting in development mode +1ms
  express:router use / query +0ms
  express:router:layer new / +0ms
  express:router use / expressInit +0ms
  express:router:layer new / +0ms
  express:router use / favicon +1ms
  express:router:layer new / +0ms
  express:router use / logger +0ms
  express:router:layer new / +0ms
  express:router use / jsonParser +0ms
  express:router:layer new / +1ms
  express:router use / urlencodedParser +0ms
  express:router:layer new / +0ms
  express:router use / cookieParser +0ms
  express:router:layer new / +0ms
  express:router use / stylus +90ms
  express:router:layer new / +0ms
  express:router use / serveStatic +0ms
  express:router:layer new / +0ms
  express:router use / router +0ms
  express:router:layer new / +1ms
  express:router use /users router +0ms
  express:router:layer new /users +0ms
  express:router use / &amp;lt;anonymous&amp;gt; +0ms
  express:router:layer new / +0ms
  express:router use / &amp;lt;anonymous&amp;gt; +0ms
  express:router:layer new / +0ms
  express:router use / &amp;lt;anonymous&amp;gt; +0ms
  express:router:layer new / +0ms
</code></pre>
<p>然后对应用程序发出请求时，您将会看到 Express 代码中指定的日志：</p>
<pre><code class="lang-console">  express:router dispatching GET / +4h
  express:router query  : / +2ms
  express:router expressInit  : / +0ms
  express:router favicon  : / +0ms
  express:router logger  : / +1ms
  express:router jsonParser  : / +0ms
  express:router urlencodedParser  : / +1ms
  express:router cookieParser  : / +0ms
  express:router stylus  : / +0ms
  express:router serveStatic  : / +2ms
  express:router router  : / +2ms
  express:router dispatching GET / +1ms
  express:view lookup &quot;index.pug&quot; +338ms
  express:view stat &quot;/projects/example/views/index.pug&quot; +0ms
  express:view render &quot;/projects/example/views/index.pug&quot; +1ms
</code></pre>
<p>要仅查看路由器实现中的日志，将 <code>DEBUG</code> 的值设置为 <code>express:router</code>。同样，要仅查看应用程序实现中的日志，将 <code>DEBUG</code> 的值设置为 <code>express:application</code>，依此类推。</p>
<h3 id="-express-">由 <code>express</code> 生成的应用程序</h3>
<p>通过 <code>express</code> 命令生成的应用程序也使用了 <code>debug</code> 模块，其调试命名空间限定为应用程序的名称。</p>
<p>例如，如果您使用 <code>$ express sample-app</code> 生成了应用程序，则可以使用以下命令启用调试语句：</p>
<pre><code class="lang-console">$ DEBUG=sample-app:* node ./bin/www
</code></pre>
<p>您可以通过将逗号分隔的名称列表分配给 <code>DEBUG</code> 来指定多个调试命名空间：</p>
<pre><code class="lang-console">$ DEBUG=http,mail,express:* node index.js
</code></pre>
<p>高级选项</p>
<p>在通过 Node.js 运行时，您可以设置一些环境变量，这些环境变量将改变调试日志记录的行为：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DEBUG</code></td>
<td>启用/禁用特定的调试命名空间。</td>
</tr>
<tr>
<td><code>DEBUG_COLORS</code></td>
<td>是否在调试输出中使用颜色。</td>
</tr>
<tr>
<td><code>DEBUG_DEPTH</code></td>
<td>对象检查深度。</td>
</tr>
<tr>
<td><code>DEBUG_FD</code></td>
<td>用于将调试输出写入的文件描述符。</td>
</tr>
<tr>
<td><code>DEBUG_SHOW_HIDDEN</code></td>
<td>在检查对象时显示隐藏属性。</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong> 以 <code>DEBUG_</code> 开头的环境变量最终会转换为一个 Options 对象，该对象与 <code>%o</code>/<code>%O</code> 格式化程序一起使用。有关完整列表，请参阅 Node.js 文档中的 <a href="https://nodejs.org/api/util.html#util_util_inspect_object_options"><code>util.inspect()</code></a>。</p>
<h3 id="-">资源</h3>
<p>有关 <code>debug</code> 的更多信息，请参阅 <a href="https://www.npmjs.com/package/debug">debug</a>。</p>

          	</article>

            <article class='markdown-body'>
            	<h2 id="-express">在反向代理后面使用 Express</h2>
<p>当在反向代理后运行 Express 应用程序时，一些 Express API 可能会返回与预期不同的值。为了进行调整，可以使用 <code>trust proxy</code> 应用程序设置来在 Express API 中公开反向代理提供的信息。最常见的问题是，暴露客户端 IP 地址的 Express API 可能会显示反向代理的内部 IP 地址而不是预期的客户端 IP 地址。</p>
<p>在配置 <code>trust proxy</code> 设置时，重要的是要了解反向代理的确切设置。由于此设置将信任请求中提供的值，因此必须确保 Express 中的设置与反向代理的操作方式相匹配。</p>
<p>应用程序设置 <code>trust proxy</code> 可以设置为以下表中列出的值之一。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔值</td>
<td>如果为 <code>true</code>，则客户端的 IP 地址被理解为 <code>X-Forwarded-For</code> 标头中最左边的条目。如果为 <code>false</code>，则该应用程序被理解为直接面向客户端，客户端的 IP 地址将从 <code>req.socket.remoteAddress</code> 获取。这是默认设置。当设置为 <code>true</code> 时，重要的是确保最后一个可信任的反向代理已删除/覆盖以下所有 HTTP 标头：<code>X-Forwarded-For</code>、<code>X-Forwarded-Host</code> 和 <code>X-Forwarded-Proto</code>，否则客户端可能会提供任何值。</td>
</tr>
<tr>
<td>IP 地址</td>
<td>IP 地址、子网或 IP 地址和子网的数组，可信任其为反向代理。以下列表显示了预配置的子网名称：loopback - <code>127.0.0.1/8</code>、<code>::1/128</code>linklocal - <code>169.254.0.0/16</code>、<code>fe80::/10</code>uniquelocal - <code>10.0.0.0/8</code>、<code>172.16.0.0/12</code>、<code>192.168.0.0/16</code>、<code>fc00::/7</code>您可以通过以下任一方式设置 IP 地址：<code>app.set(&#39;trust proxy&#39;, &#39;loopback&#39;) // 指定单个子网 app.set(&#39;trust proxy&#39;, &#39;loopback, 123.123.123.123&#39;) // 指定子网和地址 app.set(&#39;trust proxy&#39;, &#39;loopback, linklocal, uniquelocal&#39;) // 以 CSV 形式指定多个子网 app.set(&#39;trust proxy&#39;, [&#39;loopback&#39;, &#39;linklocal&#39;, &#39;uniquelocal&#39;]) // 以数组形式指定多个子网</code>当指定 IP 地址或子网时，将从地址确定过程中排除这些 IP 地址或子网，最靠近应用程序服务器的不受信任的 IP 地址将被确定为客户端的 IP 地址。这通过检查 <code>req.socket.remoteAddress</code> 是否受信任来实现。如果是，那么会从右到左逐个检查 <code>X-Forwarded-For</code> 中的每个地址，直到找到第一个不受信任的地址。</td>
</tr>
<tr>
<td>数字</td>
<td>使用距 Express 应用程序最多 <code>n</code> 个跳数的地址。<code>req.socket.remoteAddress</code> 是第一个跳数，其余的从右到左在 <code>X-Forwarded-For</code> 标头中查找。值为 <code>0</code> 意味着第一个不受信任的地址将是 <code>req.socket.remoteAddress</code>，即没有反向代理。在使用此设置时，重要的是确保没有多个不同长度的路径到达 Express 应用程序，这样客户端可以少于配置的跳数，否则客户端可能会提供任何值。</td>
</tr>
<tr>
<td>函数</td>
<td>自定义信任实现。`app.set(&#39;trust proxy&#39;, function (ip) {  if (ip === &#39;127.0.0.1&#39;</td>
<td></td>
<td>ip === &#39;123.123.123.123&#39;) return true // 受信任的 IP 地址  else return false }) `</td>
</tr>
</tbody>
</table>
<p>启用 <code>trust proxy</code> 将产生以下影响：</p>
<ul>
<li><a href="https://www.expressjs.com.cn/en/api.html#req.hostname">req.hostname</a> 的值来自于 <code>X-Forwarded-Host</code> 标头中设置的值，可以由客户端或代理设置。</li>
<li><code>X-Forwarded-Proto</code> 可以由反向代理设置为告知应用程序是否为 <code>https</code>、<code>http</code> 或甚至是无效的名称。此值会反映在 <a href="https://www.expressjs.com.cn/en/api.html#req.protocol">req.protocol</a> 中。</li>
<li><a href="https://www.expressjs.com.cn/en/api.html#req.ip">req.ip</a> 和 <a href="https://www.expressjs.com.cn/en/api.html#req.ips">req.ips</a> 的值是基于套接字地址和 <code>X-Forwarded-For</code> 标头填充的，从第一个不受信任的地址开始。</li>
</ul>
<p><code>trust proxy</code> 设置是使用 <a href="https://www.npmjs.com/package/proxy-addr">proxy-addr</a> 包实现的。有关更多信息，请参阅其文档。</p>

          	</article>

            <article class='markdown-body'>
            	<h2 id="-express-4">迁移到 Express 4</h2>
<h3 id="-">概述</h3>
<p>Express 4 与 Express 3 相比是一个重大的变化。这意味着如果在依赖项中更新 Express 版本，现有的 Express 3 应用程序将<strong>无法</strong>正常工作。</p>
<p>本文涵盖了以下内容：</p>
<ul>
<li><a href="https://www.expressjs.com.cn/guide/migrating-4.html#changes">Express 4 中的变更</a>。</li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-4.html#example-migration">将 Express 3 应用迁移到 Express 4 的示例</a>。</li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-4.html#app-gen">升级到 Express 4 应用生成器</a>。</li>
</ul>
<h3 id="express-4-">Express 4 中的变更</h3>
<p>Express 4 中有几个重大变更：</p>
<ul>
<li><a href="https://www.expressjs.com.cn/guide/migrating-4.html#core-changes">Express 核心和中间件系统的变更</a>。删除了对 Connect 的依赖以及内置中间件，因此现在必须自己添加中间件。</li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-4.html#routing">路由系统的变更</a>。</li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-4.html#other-changes">其他各种变更</a>。</li>
</ul>
<p>另请参阅：</p>
<ul>
<li><a href="https://github.com/expressjs/express/wiki/New-features-in-4.x">4.x 中的新特性</a>。</li>
<li><a href="https://github.com/expressjs/express/wiki/Migrating-from-3.x-to-4.x">从 3.x 迁移到 4.x</a>。</li>
</ul>
<h4 id="express-">Express 核心和中间件系统的变更</h4>
<p>Express 4 不再依赖于 Connect，并且从其核心中删除了所有内置中间件，仅保留 <code>express.static</code> 函数。这意味着 Express 现在是一个独立的路由和中间件 Web 框架，Express 的版本和发布不会受到中间件更新的影响。</p>
<p>没有内置中间件，必须明确添加运行应用所需的所有中间件。只需按照以下步骤操作：</p>
<ol>
<li>安装模块：<code>npm install --save &lt;module-name&gt;</code></li>
<li>在应用中引入模块：<code>require(&#39;module-name&#39;)</code></li>
<li>根据模块的文档使用：<code>app.use( ... )</code></li>
</ol>
<p>以下表格列出了 Express 3 中的中间件及其在 Express 4 中的对应物。</p>
<table>
<thead>
<tr>
<th>Express 3</th>
<th>Express 4</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>express.bodyParser</code></td>
<td><a href="https://github.com/expressjs/body-parser">body-parser</a> + <a href="https://github.com/expressjs/multer">multer</a></td>
</tr>
<tr>
<td><code>express.compress</code></td>
<td><a href="https://github.com/expressjs/compression">compression</a></td>
</tr>
<tr>
<td><code>express.cookieSession</code></td>
<td><a href="https://github.com/expressjs/cookie-session">cookie-session</a></td>
</tr>
<tr>
<td><code>express.cookieParser</code></td>
<td><a href="https://github.com/expressjs/cookie-parser">cookie-parser</a></td>
</tr>
<tr>
<td><code>express.logger</code></td>
<td><a href="https://github.com/expressjs/morgan">morgan</a></td>
</tr>
<tr>
<td><code>express.session</code></td>
<td><a href="https://github.com/expressjs/session">express-session</a></td>
</tr>
<tr>
<td><code>express.favicon</code></td>
<td><a href="https://github.com/expressjs/serve-favicon">serve-favicon</a></td>
</tr>
<tr>
<td><code>express.responseTime</code></td>
<td><a href="https://github.com/expressjs/response-time">response-time</a></td>
</tr>
<tr>
<td><code>express.errorHandler</code></td>
<td><a href="https://github.com/expressjs/errorhandler">errorhandler</a></td>
</tr>
<tr>
<td><code>express.methodOverride</code></td>
<td><a href="https://github.com/expressjs/method-override">method-override</a></td>
</tr>
<tr>
<td><code>express.timeout</code></td>
<td><a href="https://github.com/expressjs/timeout">connect-timeout</a></td>
</tr>
<tr>
<td><code>express.vhost</code></td>
<td><a href="https://github.com/expressjs/vhost">vhost</a></td>
</tr>
<tr>
<td><code>express.csrf</code></td>
<td><a href="https://github.com/expressjs/csurf">csurf</a></td>
</tr>
<tr>
<td><code>express.directory</code></td>
<td><a href="https://github.com/expressjs/serve-index">serve-index</a></td>
</tr>
<tr>
<td><code>express.static</code></td>
<td><a href="https://github.com/expressjs/serve-static">serve-static</a></td>
</tr>
</tbody>
</table>
<p>以下是 <a href="https://github.com/senchalabs/connect#middleware">Express 4 中间件的完整列表</a>。</p>
<p>在大多数情况下，您可以简单地用 Express 4 的对应中间件替换旧版本的中间件。有关详情，请参阅 GitHub 中的模块文档。</p>
<h5 id="app-use-"><code>app.use</code> 接受参数</h5>
<p>在版本 4 中，您可以使用变量参数来定义加载中间件函数的路径，然后从路由处理程序中读取参数的值。例如：</p>
<pre><code class="lang-javascript">app.use(&#39;/book/:id&#39;, function (req, res, next) {
  console.log(&#39;ID:&#39;, req.params.id)
  next()
})
</code></pre>
<h4 id="-">路由系统</h4>
<p>现在应用程序隐式加载路由中间件，因此您不再需要担心中间件的加载顺序与 <code>router</code> 中间件的关系。</p>
<p>您定义路由的方式保持不变，但是路由系统引入了两个新功能来帮助组织路由：</p>
<ul>
<li>新的方法 <code>app.route()</code> 用于为路由路径创建可链接的路由处理程序。</li>
<li>新的类 <code>express.Router</code> 用于创建可模块化挂载的路由处理程序。</li>
</ul>
<h5 id="app-route-"><code>app.route()</code> 方法</h5>
<p>新的 <code>app.route()</code> 方法使您可以为路由路径创建可链接的路由处理程序。由于路径在单个位置指定，创建模块化路由非常有帮助，减少冗余和拼写错误。有关路由的更多信息，请参阅 <a href="https://www.expressjs.com.cn/en/4x/api.html#router"><code>Router()</code> 文档</a>。</p>
<p>以下是使用 <code>app.route()</code> 函数定义的链式路由处理程序示例。</p>
<pre><code class="lang-javascript">app.route(&#39;/book&#39;)
  .get(function (req, res) {
    res.send(&#39;Get a random book&#39;)
  })
  .post(function (req, res) {
    res.send(&#39;Add a book&#39;)
  })
  .put(function (req, res) {
    res.send(&#39;Update the book&#39;)
  })
</code></pre>
<h5 id="express-router-"><code>express.Router</code> 类</h5>
<p>另一个有助于组织路</p>
<p>由的特性是新的 <code>express.Router</code> 类，您可以使用它来创建可模块化挂载的路由处理程序。<code>Router</code> 实例是一个完整的中间件和路由系统；因此，它经常被称为“迷你应用程序”。</p>
<p>以下示例创建了一个名为 <code>birds.js</code> 的路由模块，在其中加载了中间件、定义了一些路由，并将其挂载到主应用程序的路径上。</p>
<p>例如，在应用程序目录中创建一个名为 <code>birds.js</code> 的路由文件，内容如下：</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;)
var router = express.Router()

// 特定于此路由的中间件
router.use(function timeLog (req, res, next) {
  console.log(&#39;Time: &#39;, Date.now())
  next()
})
// 定义主页路由
router.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Birds home page&#39;)
})
// 定义关于路由
router.get(&#39;/about&#39;, function (req, res) {
  res.send(&#39;About birds&#39;)
})

module.exports = router
</code></pre>
<p>然后，在应用程序中加载路由模块：</p>
<pre><code class="lang-javascript">var birds = require(&#39;./birds&#39;)

// ...

app.use(&#39;/birds&#39;, birds)
</code></pre>
<p>现在，应用程序将能够处理到 <code>/birds</code> 和 <code>/birds/about</code> 路径的请求，并且将调用特定于路由的 <code>timeLog</code> 中间件。</p>
<h4 id="-">其他变更</h4>
<p>以下表格列出了 Express 4 中的其他一些小但重要的变更：</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Node.js</td>
<td>Express 4 需要 Node.js 0.10.x 或更高版本，并停止支持 Node.js 0.8.x。</td>
</tr>
<tr>
<td><code>http.createServer()</code></td>
<td>除非需要直接使用它（socket.io/SPDY/HTTPS），否则不再需要 <code>http</code> 模块。可以使用 <code>app.listen()</code> 函数启动应用程序。</td>
</tr>
<tr>
<td><code>app.configure()</code></td>
<td>移除了 <code>app.configure()</code> 函数。使用 <code>process.env.NODE_ENV</code> 或 <code>app.get(&#39;env&#39;)</code> 函数检测环境并相应地配置应用程序。</td>
</tr>
<tr>
<td><code>json spaces</code></td>
<td>在 Express 4 中，默认禁用了 <code>json spaces</code> 应用程序属性。</td>
</tr>
<tr>
<td><code>req.accepted()</code></td>
<td>使用 <code>req.accepts()</code>、<code>req.acceptsEncodings()</code>、<code>req.acceptsCharsets()</code> 和 <code>req.acceptsLanguages()</code>。</td>
</tr>
<tr>
<td><code>res.location()</code></td>
<td>不再解析相对 URL。</td>
</tr>
<tr>
<td><code>req.params</code></td>
<td>从数组变为对象。</td>
</tr>
<tr>
<td><code>res.locals</code></td>
<td>从函数变为对象。</td>
</tr>
<tr>
<td><code>res.headerSent</code></td>
<td>改为 <code>res.headersSent</code>。</td>
</tr>
<tr>
<td><code>app.route</code></td>
<td>现在作为 <code>app.mountpath</code> 可用。</td>
</tr>
<tr>
<td><code>res.on(&#39;header&#39;)</code></td>
<td>已移除。</td>
</tr>
<tr>
<td><code>res.charset</code></td>
<td>已移除。</td>
</tr>
<tr>
<td><code>res.setHeader(&#39;Set-Cookie&#39;, val)</code></td>
<td>功能现在仅限于设置基本的 cookie 值。使用 <code>res.cookie()</code> 获得更多功能。</td>
</tr>
</tbody>
</table>
<h3 id="-">示例应用程序迁移</h3>
<p>下面是将 Express 3 应用程序迁移到 Express 4 的示例。涉及的文件有 <code>app.js</code> 和 <code>package.json</code>。</p>
<h4 id="-3-">版本 3 应用程序</h4>
<h5 id="app-js"><code>app.js</code></h5>
<p>考虑一个具有以下 <code>app.js</code> 文件的 Express v.3 应用程序：</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;)
var routes = require(&#39;./routes&#39;)
var user = require(&#39;./routes/user&#39;)
var http = require(&#39;http&#39;)
var path = require(&#39;path&#39;)

var app = express()

// 所有环境
app.set(&#39;port&#39;, process.env.PORT || 3000)
app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;))
app.set(&#39;view engine&#39;, &#39;pug&#39;)
app.use(express.favicon())
app.use(express.logger(&#39;dev&#39;))
app.use(express.methodOverride())
app.use(express.session({ secret: &#39;your secret here&#39; }))
app.use(express.bodyParser())
app.use(app.router)
app.use(express.static(path.join(__dirname, &#39;public&#39;)))

// 仅限开发环境
if (app.get(&#39;env&#39;) === &#39;development&#39;) {
  app.use(express.errorHandler())
}

app.get(&#39;/&#39;, routes.index)
app.get(&#39;/users&#39;, user.list)

http.createServer(app).listen(app.get(&#39;port&#39;), function () {
  console.log(&#39;Express server listening on port &#39; + app.get(&#39;port&#39;))
})
</code></pre>
<h5 id="package-json"><code>package.json</code></h5>
<p>相应的版本 3 <code>package.json</code> 文件可能如下所示：</p>
<pre><code class="lang-json">{
  &quot;name&quot;: &quot;application-name&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node app.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;express&quot;: &quot;3.12.0&quot;,
    &quot;pug&quot;: &quot;*&quot;
  }
}
</code></pre>
<h4 id="-">过程</h4>
<p>开始迁移过程，通过以下命令安装 Express 4 应用程序所需的中间件，并将 Express 和 Pug 更新为各自的最新版本：</p>
<pre><code class="lang-console">$ npm install serve-favicon morgan method-override express-session body-parser multer errorhandler express@latest pug@latest --save
</code></pre>
<p>对 <code>app.js</code> 进行以下更改：</p>
<ol>
<li>内置的 Express 中间件函数 <code>express.favicon</code>、<code>express.logger</code>、<code>express.methodOverride</code>、<code>express.session</code>、<code>express.bodyParser</code> 和 <code>express.errorHandler</code> 不再在 <code>express</code> 对象上可用。您必须手动安装它们的替代品并在应用程序中加载它们。</li>
<li>不再需要加载 <code>app.router</code> 函数。它不是有效的 Express 4 应用程序对象，因此删除 <code>app.use(app.router);</code> 代码。</li>
<li>确保中间件函数以正确的顺序加载 - 在加载应用程序路由后加载 <code>errorHandler</code>。</li>
</ol>
<h4 id="-4-">版本 4 应用程序</h4>
<h5 id="package-json"><code>package.json</code></h5>
<p>运行上述 <code>npm</code> 命令将更新 <code>package.json</code> 如下：</p>
<pre><code class="lang-json">{
  &quot;name&quot;: &quot;application-name&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node app.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;body-parser&quot;: &quot;^1.5.2&quot;,
    &quot;errorhandler&quot;: &quot;^1.1.1&quot;,
    &quot;express&quot;: &quot;^4.8.0&quot;,
    &quot;express

-session&quot;: &quot;^1.7.2&quot;,
    &quot;pug&quot;: &quot;^2.0.0&quot;,
    &quot;method-override&quot;: &quot;^2.1.2&quot;,
    &quot;morgan&quot;: &quot;^1.2.2&quot;,
    &quot;multer&quot;: &quot;^0.1.3&quot;,
    &quot;serve-favicon&quot;: &quot;^2.0.1&quot;
  }
}
</code></pre>
<h5 id="app-js"><code>app.js</code></h5>
<p>然后，删除无效的代码，加载所需的中间件，并根据需要进行其他更改。<code>app.js</code> 文件将如下所示：</p>
<pre><code class="lang-javascript">var http = require(&#39;http&#39;)
var express = require(&#39;express&#39;)
var routes = require(&#39;./routes&#39;)
var user = require(&#39;./routes/user&#39;)
var path = require(&#39;path&#39;)

var favicon = require(&#39;serve-favicon&#39;)
var logger = require(&#39;morgan&#39;)
var methodOverride = require(&#39;method-override&#39;)
var session = require(&#39;express-session&#39;)
var bodyParser = require(&#39;body-parser&#39;)
var multer = require(&#39;multer&#39;)
var errorHandler = require(&#39;errorhandler&#39;)

var app = express()

// 所有环境
app.set(&#39;port&#39;, process.env.PORT || 3000)
app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;))
app.set(&#39;view engine&#39;, &#39;pug&#39;)
app.use(favicon(path.join(__dirname, &#39;/public/favicon.ico&#39;)))
app.use(logger(&#39;dev&#39;))
app.use(methodOverride())
app.use(session({
  resave: true,
  saveUninitialized: true,
  secret: &#39;uwotm8&#39;
}))
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: true }))
app.use(multer())
app.use(express.static(path.join(__dirname, &#39;public&#39;)))

app.get(&#39;/&#39;, routes.index)
app.get(&#39;/users&#39;, user.list)

// 在加载路由后加载错误处理中间件
if (app.get(&#39;env&#39;) === &#39;development&#39;) {
  app.use(errorHandler())
}

var server = http.createServer(app)
server.listen(app.get(&#39;port&#39;), function () {
  console.log(&#39;Express server listening on port &#39; + app.get(&#39;port&#39;))
})
</code></pre>
<p>除非需要直接使用 <code>http</code> 模块（socket.io/SPDY/HTTPS），不再需要加载它，应用程序可以简单地以如下方式启动：</p>
<pre><code class="lang-javascript">app.listen(app.get(&#39;port&#39;), function () {
  console.log(&#39;Express server listening on port &#39; + app.get(&#39;port&#39;))
})
</code></pre>
<h4 id="-">运行应用程序</h4>
<p>迁移过程已经完成，现在应用程序是一个 Express 4 应用程序。要确认，通过以下命令启动应用程序：</p>
<pre><code class="lang-console">$ node .
</code></pre>
<p>加载 <a href="http://localhost:3000/">http://localhost:3000</a>，查看由 Express 4 渲染的主页。</p>
<h3 id="-express-4-">升级到 Express 4 应用生成器</h3>
<p>用于生成 Express 应用程序的命令行工具仍然是 <code>express</code>，但要升级到新版本，必须先卸载 Express 3 应用生成器，然后安装新的 <code>express-generator</code>。</p>
<h4 id="-">安装</h4>
<p>如果您已经在系统上安装了 Express 3 应用生成器，必须卸载它：</p>
<pre><code class="lang-console">$ npm uninstall -g express
</code></pre>
<p>根据文件和目录权限配置的情况，您可能需要使用 <code>sudo</code> 运行此命令。</p>
<p>现在安装新的生成器：</p>
<pre><code class="lang-console">$ npm install -g express-generator
</code></pre>
<p>根据文件和目录权限配置的情况，您可能需要使用 <code>sudo</code> 运行此命令。</p>
<p>现在，您系统上的 <code>express</code> 命令已经更新为 Express 4 生成器。</p>
<h4 id="-">应用生成器的变更</h4>
<p>命令选项和用法在很大程度上保持不变，但有以下例外：</p>
<ul>
<li>移除了 <code>--sessions</code> 选项。</li>
<li>移除了 <code>--jshtml</code> 选项。</li>
<li>添加了 <code>--hogan</code> 选项以支持 <a href="http://twitter.github.io/hogan.js/">Hogan.js</a>。</li>
</ul>
<h4 id="-">示例</h4>
<p>执行以下命令以创建一个 Express 4 应用程序：</p>
<pre><code class="lang-console">$ express app4
</code></pre>
<p>如果查看 <code>app4/app.js</code> 文件的内容，您会注意到除了 <code>express.static</code> 之外，应用程序所需的所有中间件函数都被加载为独立模块，而 <code>router</code> 中间件不再在应用程序中显式加载。</p>
<p>您还会注意到，<code>app.js</code> 文件现在是一个 Node.js 模块，与旧</p>
<p>版本的 Express 3 应用程序不同，其中 <code>app.listen()</code> 被调用以启动服务器，而不是通过 <code>http.createServer()</code>。</p>
<h3 id="-">结论</h3>
<p>​        Express 4 是一个重要的升级，引入了许多变化和新特性。尽管升级过程可能会有一些复杂性，但通过逐步进行，并参考官方文档和示例，您可以顺利地将现有的 Express 3 应用程序迁移到 Express 4，从而利用新的功能和改进。在迁移过程中，确保备份应用程序代码和配置，以防万一需要还原。如果需要使用 Express 3 的功能，您可以继续使用旧版本，但为了充分利用最新的功能和安全性，推荐尽早迁移到 Express 4。</p>

          	</article>

            <article class='markdown-body'>
            	<h2 id="-express-5">迁移到 Express 5</h2>
<h3 id="-">概述</h3>
<p>Express 5.0 目前仍处于 alpha 版本阶段，但是下面是即将发布的版本中的更改预览，以及如何将您的 Express 4 应用迁移到 Express 5。</p>
<p>Express 5 与 Express 4 相比没有太大的区别：API 的变化并不像从 3.0 到 4.0 那样显著。尽管基本的 API 保持不变，但仍然存在着一些破坏性的变更；换句话说，如果您将应用程序更新到使用 Express 5，现有的 Express 4 程序可能无法正常工作。</p>
<p>要安装最新的 alpha 版本并预览 Express 5，请在您的应用根目录中输入以下命令：</p>
<pre><code class="lang-console">$ npm install express@&gt;=5.0.0-alpha.8 --save
</code></pre>
<p>然后，您可以运行自动化测试，查看哪些测试失败，并根据下面的更新修复问题。在解决测试失败后，运行您的应用程序，查看发生了哪些错误。您会立即发现是否使用了任何不受支持的方法或属性。</p>
<h3 id="express-5-">Express 5 中的变化</h3>
<p>以下是将影响到您作为 Express 用户的变化列表（截至 alpha 2 发布）。可以查看<a href="https://github.com/expressjs/express/pull/2237">拉取请求</a>以获取所有计划特性的列表。</p>
<p><strong>已移除的方法和属性</strong></p>
<ul>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#app.del">app.del()</a></li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#app.param">app.param(fn)</a></li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#plural">复数形式的方法名</a></li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#leading">app.param(name, fn) 中 name 参数中的前导冒号</a></li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#req.param">req.param(name)</a></li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#res.json">res.json(obj, status)</a></li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#res.jsonp">res.jsonp(obj, status)</a></li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#res.send.body">res.send(body, status)</a></li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#res.send.status">res.send(status)</a></li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#res.sendfile">res.sendfile()</a></li>
</ul>
<p><strong>已更改的部分</strong></p>
<ul>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#app.router">app.router</a></li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#req.host">req.host</a></li>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#req.query">req.query</a></li>
</ul>
<p><strong>改进</strong></p>
<ul>
<li><a href="https://www.expressjs.com.cn/guide/migrating-5.html#res.render">res.render()</a></li>
</ul>
<h4 id="-">已移除的方法和属性</h4>
<p>如果您在应用程序中使用了以下任何方法或属性，它将会崩溃。因此，在更新到版本 5 后，您需要更改您的应用程序。</p>
<h5 id="app-del-">app.del()</h5>
<p>Express 5 不再支持 <code>app.del()</code> 函数。如果使用此函数，将会抛出错误。要注册 HTTP DELETE 路由，请改用 <code>app.delete()</code> 函数。</p>
<p>最初，<code>del</code> 被用于代替 <code>delete</code>，因为在 JavaScript 中 <code>delete</code> 是一个保留关键字。然而，从 ECMAScript 6 开始，<code>delete</code> 和其他保留关键字可以合法地用作属性名。</p>
<h5 id="app-param-fn-">app.param(fn)</h5>
<p><code>app.param(fn)</code> 签名用于修改 <code>app.param(name, fn)</code> 函数的行为。自 v4.11.0 以来，它已被弃用，并且 Express 5 不再支持它。</p>
<h5 id="-">复数形式的方法名</h5>
<p>以下方法名已经变为复数形式。在 Express 4 中，使用旧方法会导致警告。Express 5 不再支持这些方法：</p>
<ul>
<li><code>req.acceptsCharset()</code> 被替换为 <code>req.acceptsCharsets()</code>。</li>
<li><code>req.acceptsEncoding()</code> 被替换为 <code>req.acceptsEncodings()</code>。</li>
<li><code>req.acceptsLanguage()</code> 被替换为 <code>req.acceptsLanguages()</code>。</li>
</ul>
<h5 id="-app-param-name-fn-name-">在 app.param(name, fn) 的 name 参数中的前导冒号 (:)</h5>
<p>在 <code>app.param(name, fn)</code> 函数的 name 参数中的前导冒号字符 (:) 是 Express 3 的遗留物，为了向后兼容，Express 4 支持它并显示了弃用通知。Express 5 将会忽略它，并使用不带冒号前缀的 name 参数。</p>
<p>如果您遵循 Express 4 的 [app.param](<a href="https://www.expressjs.com.cn/en/4x/api.html">https://www.expressjs.com.cn/en/4x/api.html</a></p>
<p>#app.param) 文档，这不应该影响您的代码，因为文档中没有提及前导冒号。</p>
<h5 id="req-param-name-">req.param(name)</h5>
<p>已移除此种可能会令人困惑且危险的检索表单数据的方法。现在您需要在 <code>req.params</code>、<code>req.body</code> 或 <code>req.query</code> 对象中专门查找提交的参数名。</p>
<h5 id="res-json-obj-status-">res.json(obj, status)</h5>
<p>Express 5 不再支持 <code>res.json(obj, status)</code> 的签名。取而代之的是，首先设置状态，然后将其链接到 <code>res.json()</code> 方法，例如：<code>res.status(status).json(obj)</code>。</p>
<h5 id="res-jsonp-obj-status-">res.jsonp(obj, status)</h5>
<p>Express 5 不再支持 <code>res.jsonp(obj, status)</code> 的签名。取而代之的是，首先设置状态，然后将其链接到 <code>res.jsonp()</code> 方法，例如：<code>res.status(status).jsonp(obj)</code>。</p>
<h5 id="res-send-body-status-">res.send(body, status)</h5>
<p>Express 5 不再支持 <code>res.send(obj, status)</code> 的签名。取而代之的是，首先设置状态，然后将其链接到 <code>res.send()</code> 方法，例如：<code>res.status(status).send(obj)</code>。</p>
<h5 id="res-send-status-">res.send(status)</h5>
<p>Express 5 不再支持 <code>res.send(*status*)</code> 的签名，其中 <em><code>status</code></em> 是一个数字。取而代之的是，使用 <code>res.sendStatus(statusCode)</code> 函数，它设置 HTTP 响应头状态码并发送代码的文本版本，例如：“Not Found”、“Internal Server Error” 等等。如果您需要使用 <code>res.send()</code> 函数发送一个数字，请将数字引用起来，将其转换为字符串，以便 Express 不将其解释为尝试使用不受支持的旧签名。</p>
<h5 id="res-sendfile-">res.sendfile()</h5>
<p>在 Express 5 中，<code>res.sendfile()</code> 函数已被驼峰命名版本 <code>res.sendFile()</code> 取代。</p>
<h4 id="-">已更改的部分</h4>
<h5 id="app-router">app.router</h5>
<p><code>app.router</code> 对象在 Express 4 中被移除，但在 Express 5 中已经重新引入。在新版本中，此对象仅仅是对基础 Express 路由器的引用，不像在 Express 3 中，应用程序必须显式地加载它。</p>
<h5 id="req-host">req.host</h5>
<p>在 Express 4 中，<code>req.host</code> 函数会错误地删除掉端口号，如果存在的话。在 Express 5 中，端口号会被保留。</p>
<h5 id="req-query">req.query</h5>
<p>在 Express 4.7 和 Express 5 及以后版本中，查询解析选项可以接受 <code>false</code> 来禁用查询字符串解析，当您希望使用自己的函数进行查询字符串解析逻辑时可以这样做。</p>
<h4 id="-">改进</h4>
<h5 id="res-render-">res.render()</h5>
<p>这个方法现在对于所有视图引擎都强制执行异步行为，避免了由视图引擎具有同步实现引起的 bug，因为这些实现违反了推荐的接口。</p>

          	</article>

            <article class='markdown-body'>
            	<h2 id="-">数据库集成</h2>
<p>向 Express 应用添加连接数据库的功能只是在应用中加载适当的 Node.js 数据库驱动程序。本文档简要介绍如何在 Express 应用中添加和使用一些最受欢迎的 Node.js 数据库系统模块：</p>
<ul>
<li><a href="https://www.expressjs.com.cn/guide/database-integration.html#cassandra">Cassandra</a></li>
<li><a href="https://www.expressjs.com.cn/guide/database-integration.html#couchbase">Couchbase</a></li>
<li><a href="https://www.expressjs.com.cn/guide/database-integration.html#couchdb">CouchDB</a></li>
<li><a href="https://www.expressjs.com.cn/guide/database-integration.html#leveldb">LevelDB</a></li>
<li><a href="https://www.expressjs.com.cn/guide/database-integration.html#mysql">MySQL</a></li>
<li><a href="https://www.expressjs.com.cn/guide/database-integration.html#mongodb">MongoDB</a></li>
<li><a href="https://www.expressjs.com.cn/guide/database-integration.html#neo4j">Neo4j</a></li>
<li><a href="https://www.expressjs.com.cn/guide/database-integration.html#oracle">Oracle</a></li>
<li><a href="https://www.expressjs.com.cn/guide/database-integration.html#postgresql">PostgreSQL</a></li>
<li><a href="https://www.expressjs.com.cn/guide/database-integration.html#redis">Redis</a></li>
<li><a href="https://www.expressjs.com.cn/guide/database-integration.html#sql-server">SQL Server</a></li>
<li><a href="https://www.expressjs.com.cn/guide/database-integration.html#sqlite">SQLite</a></li>
<li><a href="https://www.expressjs.com.cn/guide/database-integration.html#elasticsearch">Elasticsearch</a></li>
</ul>
<p>这些数据库驱动程序只是众多可用驱动程序之一。对于其他选项，请在 <a href="https://www.npmjs.com/">npm</a> 网站上进行搜索。</p>
<h3 id="cassandra">Cassandra</h3>
<p><strong>模块</strong>: <a href="https://github.com/datastax/nodejs-driver">cassandra-driver</a></p>
<h4 id="-">安装</h4>
<pre><code class="lang-console">$ npm install cassandra-driver
</code></pre>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">var cassandra = require(&#39;cassandra-driver&#39;)
var client = new cassandra.Client({ contactPoints: [&#39;localhost&#39;] })

client.execute(&#39;select key from system.local&#39;, function (err, result) {
  if (err) throw err
  console.log(result.rows[0])
})
</code></pre>
<h3 id="couchbase">Couchbase</h3>
<p><strong>模块</strong>: <a href="https://github.com/couchbase/couchnode">couchnode</a></p>
<h4 id="-">安装</h4>
<pre><code class="lang-console">$ npm install couchbase
</code></pre>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">var couchbase = require(&#39;couchbase&#39;)
var bucket = (new couchbase.Cluster(&#39;http://localhost:8091&#39;)).openBucket(&#39;bucketName&#39;)

// 向存储桶添加文档
bucket.insert(&#39;document-key&#39;, { name: &#39;Matt&#39;, shoeSize: 13 }, function (err, result) {
  if (err) {
    console.log(err)
  } else {
    console.log(result)
  }
})

// 获取所有鞋码为 13 的文档
var n1ql = &#39;SELECT d.* FROM `bucketName` d WHERE shoeSize = $1&#39;
var query = N1qlQuery.fromString(n1ql)
bucket.query(query, [13], function (err, result) {
  if (err) {
    console.log(err)
  } else {
    console.log(result)
  }
})
</code></pre>
<h3 id="couchdb">CouchDB</h3>
<p><strong>模块</strong>: <a href="https://github.com/dscape/nano">nano</a></p>
<h4 id="-">安装</h4>
<pre><code class="lang-console">$ npm install nano
</code></pre>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">var nano = require(&#39;nano&#39;)(&#39;http://localhost:5984&#39;)
nano.db.create(&#39;books&#39;)
var books = nano.db.use(&#39;books&#39;)

// 在 books 数据库中插入书籍文档
books.insert({ name: &#39;The Art of war&#39; }, null, function (err, body) {
  if (err) {
    console.log(err)
  } else {
    console.log(body)
  }
})

// 获取所有书籍
books.list(function (err, body) {
  if (err) {
    console.log(err)
  } else {
    console.log(body.rows)
  }
})
</code></pre>
<h3 id="leveldb">LevelDB</h3>
<p><strong>模块</strong>: <a href="https://github.com/rvagg/node-levelup">levelup</a></p>
<h4 id="-">安装</h4>
<pre><code class="lang-console">$ npm install level levelup leveldown
</code></pre>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">var levelup = require(&#39;levelup&#39;)
var db = levelup(&#39;./mydb&#39;)

db.put(&#39;name&#39;, &#39;LevelUP&#39;, function (err) {
  if (err) return console.log(&#39;哎呀！&#39;, err)

  db.get(&#39;name&#39;, function (err, value) {
    if (err) return console.log(&#39;哎呀！&#39;, err)

    console.log(&#39;name=&#39; + value)
  })
})
</code></pre>
<h3 id="mysql">MySQL</h3>
<p><strong>模块</strong>: <a href="https://github.com/felixge/node-mysql/">mysql</a></p>
<h4 id="-">安装</h4>
<pre><code class="lang-console">$ npm install mysql
</code></pre>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">var mysql = require(&#39;mysql&#39;)
var connection = mysql.createConnection({
  host: &#39;localhost&#39;,
  user: &#39;dbuser&#39;,
  password: &#39;s3kreee7&#39;,
  database: &#39;my_db&#39;
})

connection.connect()

connection.query(&#39;SELECT 1 + 1 AS solution&#39;, function (err, rows, fields) {
  if (err) throw err

  console.log(&#39;The solution is: &#39;, rows[0].solution)
})

connection.end()
</code></pre>
<h3 id="mongodb">MongoDB</h3>
<p><strong>模块</strong>: <a href="https://github.com/mongodb/node-mongodb-native">mongodb</a></p>
<h4 id="-">安装</h4>
<pre><code class="lang-console">$ npm install mongodb
</code></pre>
<h4 id="-v2-">示例（v2.*）</h4>
<pre><code class="lang-javascript">var MongoClient = require(&#39;mongodb&#39;).MongoClient

MongoClient.connect(&#39;mongodb://localhost:27017/animals&#39;, function (err, db) {
  if (err) throw err

  db.collection(&#39;mammals&#39;).find().toArray(function (err, result) {
    if (err) throw err

    console.log(result)
  })
})
</code></pre>
<h4 id="-v3-">示例（v3.*）</h4>
<pre><code class="lang-javascript">var MongoClient = require(&#39;mongodb&#39;).MongoClient

MongoClient.connect(&#39;mongodb://localhost:27017/animals&#39;, function (err, client) {
  if (err) throw err

  var db = client.db(&#39;animals&#39;)

  db.collection(&#39;mammals&#39;).find().toArray(function (err, result) {
    if (err) throw err

    console.log(result)
  })
})
</code></pre>
<p>如果您想要一个针对 MongoDB 的对象模型驱动程序，可以查看 <a href="https://github.com/LearnBoost/mongoose">Mongoose</a>。</p>
<h3 id="neo4j">Neo4j</h3>
<p><strong>模块</strong>: <a href="https://github.com/neo4j/neo4j-javascript-driver">neo4j-driver</a></p>
<h4 id="-">安装</h4>
<pre><code class="lang-console">$ npm install neo4j-driver
</code></pre>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">var neo4j = require(&#39;neo4j-driver&#39;)
var driver = neo4j

.driver(&#39;neo4j://localhost:7687&#39;, neo4j.auth.basic(&#39;neo4j&#39;, &#39;letmein&#39;))

var session = driver.session()

session.readTransaction(function (tx) {
  return tx.run(&#39;MATCH (n) RETURN count(n) AS count&#39;)
    .then(function (res) {
      console.log(res.records[0].get(&#39;count&#39;))
    })
    .catch(function (error) {
      console.log(error)
    })
})
</code></pre>
<h3 id="oracle">Oracle</h3>
<p><strong>模块</strong>: <a href="https://github.com/oracle/node-oracledb">oracledb</a></p>
<h4 id="-">安装</h4>
<p>注意：<a href="https://github.com/oracle/node-oracledb#-installation">参见安装先决条件</a>。</p>
<pre><code class="lang-console">$ npm install oracledb
</code></pre>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">const oracledb = require(&#39;oracledb&#39;)
const config = {
  user: &#39;&lt;your db user&gt;&#39;,
  password: &#39;&lt;your db password&gt;&#39;,
  connectString: &#39;localhost:1521/orcl&#39;
}

async function getEmployee (empId) {
  let conn

  try {
    conn = await oracledb.getConnection(config)

    const result = await conn.execute(
      &#39;select * from employees where employee_id = :id&#39;,
      [empId]
    )

    console.log(result.rows[0])
  } catch (err) {
    console.log(&#39;Ouch!&#39;, err)
  } finally {
    if (conn) { // conn assignment worked, need to close
      await conn.close()
    }
  }
}

getEmployee(101)
</code></pre>
<h3 id="postgresql">PostgreSQL</h3>
<p><strong>模块</strong>: <a href="https://github.com/vitaly-t/pg-promise">pg-promise</a></p>
<h4 id="-">安装</h4>
<pre><code class="lang-console">$ npm install pg-promise
</code></pre>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">var pgp = require(&#39;pg-promise&#39;)(/* options */)
var db = pgp(&#39;postgres://username:password@host:port/database&#39;)

db.one(&#39;SELECT $1 AS value&#39;, 123)
  .then(function (data) {
    console.log(&#39;DATA:&#39;, data.value)
  })
  .catch(function (error) {
    console.log(&#39;ERROR:&#39;, error)
  })
</code></pre>
<h3 id="redis">Redis</h3>
<p><strong>模块</strong>: <a href="https://github.com/mranney/node_redis">redis</a></p>
<h4 id="-">安装</h4>
<pre><code class="lang-console">$ npm install redis
</code></pre>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">var redis = require(&#39;redis&#39;)
var client = redis.createClient()

client.on(&#39;error&#39;, function (err) {
  console.log(&#39;Error &#39; + err)
})

client.set(&#39;string key&#39;, &#39;string val&#39;, redis.print)
client.hset(&#39;hash key&#39;, &#39;hashtest 1&#39;, &#39;some value&#39;, redis.print)
client.hset([&#39;hash key&#39;, &#39;hashtest 2&#39;, &#39;some other value&#39;], redis.print)

client.hkeys(&#39;hash key&#39;, function (err, replies) {
  console.log(replies.length + &#39; replies:&#39;)

  replies.forEach(function (reply, i) {
    console.log(&#39;    &#39; + i + &#39;: &#39; + reply)
  })

  client.quit()
})
</code></pre>
<h3 id="sql-server">SQL Server</h3>
<p><strong>模块</strong>: <a href="https://github.com/tediousjs/tedious">tedious</a></p>
<h4 id="-">安装</h4>
<pre><code class="lang-console">$ npm install tedious
</code></pre>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">var Connection = require(&#39;tedious&#39;).Connection
var Request = require(&#39;tedious&#39;).Request

var config = {
  server: &#39;localhost&#39;,
  authentication: {
    type: &#39;default&#39;,
    options: {
      userName: &#39;your_username&#39;, // 更新为实际用户名
      password: &#39;your_password&#39; // 更新为实际密码
    }
  }
}

var connection = new Connection(config)

connection.on(&#39;connect&#39;, function (err) {
  if (err) {
    console.log(err)
  } else {
    executeStatement()
  }
})

function executeStatement () {
  request = new Request(&quot;select 123, &#39;hello world&#39;&quot;, function (err, rowCount) {
    if (err) {
      console.log(err)
    } else {
      console.log(rowCount + &#39; 行&#39;)
    }
    connection.close()
  })

  request.on(&#39;row&#39;, function (columns) {
    columns.forEach(function (column) {
      if (column.value === null) {
        console.log(&#39;NULL&#39;)
      } else {
        console.log(column.value)
      }
    })
  })

  connection.execSql(request)
}
</code></pre>
<h3 id="sqlite">SQLite</h3>
<p><strong>模块</strong>: <a href="https://github.com/mapbox/node-sqlite3">sqlite3</a></p>
<h4 id="-">安装</h4>
<pre><code class="lang-console">$ npm install sqlite3
</code></pre>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">var sqlite3 = require(&#39;sqlite3&#39;).verbose()
var db = new sqlite3.Database(&#39;:memory:&#39;)

db.serialize(function () {
  db.run(&#39;CREATE TABLE lorem (info TEXT)&#39;)
  var stmt = db.prepare(&#39;INSERT INTO lorem VALUES (?)&#39;)

  for (var i = 0; i &lt; 10; i++) {
    stmt.run(&#39;Ipsum &#39; + i)
  }

  stmt.finalize()

  db.each(&#39;SELECT rowid AS id, info FROM lorem&#39;, function (err, row) {
    console.log(row.id + &#39;: &#39; + row.info)
  })
})

db.close()
</code></pre>
<h3 id="elasticsearch">Elasticsearch</h3>
<p><strong>模块</strong>: <a href="https://github.com/elastic/elasticsearch-js">elasticsearch</a></p>
<h4 id="-">安装</h4>
<pre><code class="lang-console">$ npm install elasticsearch
</code></pre>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">var elasticsearch = require(&#39;elasticsearch&#39;)
var client = elasticsearch.Client({
  host: &#39;localhost:9200&#39;
})

client.search({
  index: &#39;books&#39;,
  type: &#39;book&#39;,
  body: {
    query: {
      multi_match: {
        query: &#39;express js&#39;,
        fields: [&#39;title&#39;, &#39;description&#39;]
      }
    }
  }
}).then(function (response) {
  var hits = response.hits.hits
}, function (error) {
  console.trace(error.message)
})
</code></pre>

          	</article>
	</div>
</body>

</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript">
	<!--
	$(document).ready(function(){
		var css_conf = eval(markdown_panel_style);
		$('#readme').css(css_conf)
	    
		var conf = eval(jquery_ztree_toc_opts);
			$('#tree').ztree_toc(conf);
	});
	//-->
</SCRIPT>